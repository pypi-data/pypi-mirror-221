"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([["app_gettingStartedDocs_elixir_elixir_tsx"],{"./app/gettingStartedDocs/elixir/elixir.tsx":(e,n,t)=>{t.r(n),t.d(n,{GettingStartedWithElixir:()=>c,default:()=>u,steps:()=>l});var o=t("../node_modules/react/index.js"),i=t("./app/components/links/externalLink.tsx"),r=t("./app/components/onboarding/gettingStartedDoc/layout.tsx"),d=t("./app/components/onboarding/gettingStartedDoc/step.tsx"),a=t("./app/locale.tsx"),s=t("../node_modules/@emotion/react/jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js");const l=function(){let{dsn:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return[{type:d.WU.INSTALL,description:(0,s.tZ)("p",{children:(0,a._N)("Edit your [mixCode:mix.exs] file to add it as a dependency and add the [sentryCode::sentry] package to your applications:",{sentryCode:(0,s.tZ)("code",{}),mixCode:(0,s.tZ)("code",{})})}),configurations:[{language:"elixir",description:(0,s.tZ)("p",{children:(0,a._N)("Install [code:sentry-sdk]:",{code:(0,s.tZ)("code",{})})}),code:'\ndefp deps do\n  [\n    # ...\n    {:sentry, "~> 8.0"},\n    {:jason, "~> 1.1"},\n    {:hackney, "~> 1.8"},\n    # if you are using plug_cowboy\n    {:plug_cowboy, "~> 2.3"}\n  ]\nend\n        '}]},{type:d.WU.CONFIGURE,description:(0,s.tZ)("p",{children:(0,a._N)("Setup the application production environment in your [code:config/prod.exs]",{code:(0,s.tZ)("code",{})})}),configurations:[{language:"elixir",code:`\nconfig :sentry,\ndsn: "${e}",\nenvironment_name: :prod,\nenable_source_code_context: true,\nroot_source_code_path: File.cwd!(),\ntags: %{\n  env: "production"\n},\nincluded_environments: [:prod]\n        `},{description:(0,s.BX)(o.Fragment,{children:[(0,s.tZ)("p",{children:(0,a._N)("The [environmentNameCode:environment_name] and [includedEnvironmentsCode:included_environments] work together to determine if and when Sentry should record exceptions. The [environmentNameCode:environment_name] is the name of the current environment. In the example above, we have explicitly set the environment to [prodCode::prod] which works well if you are inside an environment specific configuration like [configCode:config/prod.exs].",{environmentNameCode:(0,s.tZ)("code",{}),includedEnvironmentsCode:(0,s.tZ)("code",{}),prodCode:(0,s.tZ)("code",{}),configCode:(0,s.tZ)("code",{})})}),(0,s.tZ)("p",{children:(0,a._N)("An alternative is to use [code:Mix.env] in your general configuration file:",{code:(0,s.tZ)("code",{})})})]}),configurations:[{language:"elixir",code:`\nconfig :sentry, dsn: "${e}",\nincluded_environments: [:prod],\nenvironment_name: Mix.env\n            `}]},{description:(0,s.BX)(o.Fragment,{children:[(0,s.tZ)("p",{children:(0,a._N)("This will set the environment name to whatever the current Mix environment atom is, but it will only send events if the current environment is [prodCode::prod], since that is the only entry in the [includedEnvironmentsCode:included_environments] key.",{prodCode:(0,s.tZ)("code",{}),includedEnvironmentsCode:(0,s.tZ)("code",{})})}),(0,a.t)("You can even rely on more custom determinations of the environment name. It's not uncommon for most applications to have a 'staging' environment. In order to handle this without adding an additional Mix environment, you can set an environment variable that determines the release level.")]}),language:"elixir",code:`\nconfig :sentry, dsn: "${e}",\nincluded_environments: ~w(production staging),\nenvironment_name: System.get_env("RELEASE_LEVEL") || "development"\n        `},{description:(0,s.BX)(o.Fragment,{children:[(0,s.tZ)("p",{children:(0,a._N)("In this example, we are getting the environment name from the [code:RELEASE_LEVEL] environment variable. If that variable does not exist, it will default to [code:'development']. Now, on our servers, we can set the environment variable appropriately. On our local development machines, exceptions will never be sent, because the default value is not in the list of [code:included_environments].",{code:(0,s.tZ)("code",{})})}),(0,s.tZ)("p",{children:(0,a._N)("If using an environment with Plug or Phoenix, add the following to [plugRouterCode:Plug.Router] or [phoenixEndpointCode:Phoenix.Endpoint]:",{plugRouterCode:(0,s.tZ)("code",{}),phoenixEndpointCode:(0,s.tZ)("code",{})})})]}),language:"elixir",code:'\n# Phoenix\nuse Sentry.PlugCapture\nuse Phoenix.Endpoint, otp_app: :my_app\n# ...\nplug Plug.Parsers,\n  parsers: [:urlencoded, :multipart, :json],\n  pass: ["*/*"],\n  json_decoder: Phoenix.json_library()\nplug Sentry.PlugContext\n# Plug\nuse Plug.Router\nuse Sentry.PlugCapture\n# ...\nplug Plug.Parsers,\n  parsers: [:urlencoded, :multipart, :json],\n  pass: ["*/*"],\n  json_decoder: Phoenix.json_library()\nplug Sentry.PlugContext\n        ',additionalInfo:(0,s.tZ)("p",{children:(0,a._N)("[sentryPlugContextCode:Sentry.PlugContext] gathers the contextual information for errors, and [sentryPlugCaptureCode:Sentry.PlugCapture] captures and sends any errors that occur in the Plug stack. [sentryPlugContextCode:Sentry.PlugContext] should be below [sentryPlugParsersCode:Plug.Parsers] if you are using it.",{sentryPlugCaptureCode:(0,s.tZ)("code",{}),sentryPlugContextCode:(0,s.tZ)("code",{}),sentryPlugParsersCode:(0,s.tZ)("code",{})})})}]},{title:(0,a.t)("Capture Crashed Process Exceptions"),description:(0,s.tZ)("p",{children:(0,a._N)("This library comes with an extension to capture all error messages that the Plug handler might not. This is based on [link:Logger.Backend]. You can add it as a backend when your application starts:",{link:(0,s.tZ)(i.Z,{href:"https://hexdocs.pm/logger/Logger.html#module-backends"})})}),configurations:[{language:"elixir",code:"\n# lib/my_app/application.ex\n\ndef start(_type, _args) do\n  Logger.add_backend(Sentry.LoggerBackend)\n        "}]},{title:(0,a.t)("Capturing Errors"),description:(0,s.BX)(o.Fragment,{children:[(0,a.t)("If you use the LoggerBackend and set up the Plug/Phoenix integrations, all errors will bubble up to Sentry."),(0,s.tZ)("p",{children:(0,a.t)("Otherwise, we provide a simple way to capture exceptions manually:")})]}),configurations:[{language:"elixir",code:"\ntry do\n  ThisWillError.really()\nrescue\n  my_exception ->\n    Sentry.capture_exception(my_exception, [stacktrace: __STACKTRACE__, extra: %{extra: information}])\nend\n        "}]}]};function c(e){let{dsn:n,...t}=e;return(0,s.tZ)(r.A,{steps:l({dsn:n}),...t})}c.displayName="GettingStartedWithElixir";const u=c}}]);
//# sourceMappingURL=../sourcemaps/app_gettingStartedDocs_elixir_elixir_tsx.df972e9920a5f1b3d44545f3c7c95a11.js.map