{"version":3,"file":"chunks/vendors-node_modules_dnd-kit_accessibility_dist_accessibility_esm_js-node_modules_react-grid--85d690.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js","webpack:///../node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\n\nconst hiddenStyles = {\n  display: 'none'\n};\nfunction HiddenText({\n  id,\n  value\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: hiddenStyles\n  }, value);\n}\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: 1,\n  height: 1,\n  margin: -1,\n  border: 0,\n  padding: 0,\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  clipPath: 'inset(100%)',\n  whiteSpace: 'nowrap'\n};\nfunction LiveRegion({\n  id,\n  announcement\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: visuallyHidden,\n    role: \"status\",\n    \"aria-live\": \"assertive\",\n    \"aria-atomic\": true\n  }, announcement);\n}\n\nfunction useAnnouncement() {\n  const [announcement, setAnnouncement] = useState('');\n  const announce = useCallback(value => {\n    if (value != null) {\n      setAnnouncement(value);\n    }\n  }, []);\n  return {\n    announce,\n    announcement\n  };\n}\n\nexport { HiddenText, LiveRegion, useAnnouncement };\n//# sourceMappingURL=accessibility.esm.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"names":["hiddenStyles","display","HiddenText","id","value","style","visuallyHidden","position","width","height","margin","border","padding","overflow","clip","clipPath","whiteSpace","LiveRegion","announcement","role","useAnnouncement","setAnnouncement","useState","announce","useCallback","Object","defineProperty","exports","bottom","childrenEqual","a","b","_lodash","default","_react","Children","map","c","key","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","props","_ref3","verticalCompact","correctBounds","fastPositionEqual","left","top","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","num","setTopLeft","_ref2","concat","setTransform","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","initialLayout","children","cols","allowOverlap","layout","forEach","child","exists","String","push","isProduction","_grid","console","warn","g","validateLayout","_objectSpread","i","w","h","x","y","correctedLayout","withLayoutItem","itemKey","cb","item","_interopRequireDefault","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","target","arguments","length","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","DEBUG","bottomY","max","len","newLayout","Array","layoutItem","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","l1","l2","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","otherItem","fullLayout","compactH","Math","min","bounds","collidesWith","isUserAction","preventCollision","log","oldX","oldY","reverse","collisions","hasCollisions","collision","itemToMove","compactV","fakeItem","undefined","slice","sort","contextName","subProps","isArray","Error","j","_console"],"sourceRoot":""}