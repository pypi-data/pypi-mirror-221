{"version":3,"file":"chunks/vendors-node_modules_dnd-kit_accessibility_dist_accessibility_esm_js-node_modules_lodash_clon-53d43e.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js","webpack:///../node_modules/lodash/cloneDeep.js","webpack:///../node_modules/lodash/isNil.js","webpack:///../node_modules/lodash/isNumber.js","webpack:///../node_modules/lodash/maxBy.js","webpack:///../node_modules/lodash/orderBy.js","webpack:///../node_modules/lodash/set.js","webpack:///../node_modules/lodash/uniqBy.js","webpack:///../node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\n\nconst hiddenStyles = {\n  display: 'none'\n};\nfunction HiddenText({\n  id,\n  value\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: hiddenStyles\n  }, value);\n}\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: 1,\n  height: 1,\n  margin: -1,\n  border: 0,\n  padding: 0,\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  clipPath: 'inset(100%)',\n  whiteSpace: 'nowrap'\n};\nfunction LiveRegion({\n  id,\n  announcement\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: visuallyHidden,\n    role: \"status\",\n    \"aria-live\": \"assertive\",\n    \"aria-atomic\": true\n  }, announcement);\n}\n\nfunction useAnnouncement() {\n  const [announcement, setAnnouncement] = useState('');\n  const announce = useCallback(value => {\n    if (value != null) {\n      setAnnouncement(value);\n    }\n  }, []);\n  return {\n    announce,\n    announcement\n  };\n}\n\nexport { HiddenText, LiveRegion, useAnnouncement };\n//# sourceMappingURL=accessibility.esm.js.map\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * This method is like `_.max` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.maxBy(objects, function(o) { return o.n; });\n * // => { 'n': 2 }\n *\n * // The `_.property` iteratee shorthand.\n * _.maxBy(objects, 'n');\n * // => { 'n': 2 }\n */\nfunction maxBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)\n    : undefined;\n}\n\nmodule.exports = maxBy;\n","var baseOrderBy = require('./_baseOrderBy'),\n    isArray = require('./isArray');\n\n/**\n * This method is like `_.sortBy` except that it allows specifying the sort\n * orders of the iteratees to sort by. If `orders` is unspecified, all values\n * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n * descending or \"asc\" for ascending sort order of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @param {string[]} [orders] The sort orders of `iteratees`.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 34 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 36 }\n * ];\n *\n * // Sort by `user` in ascending order and by `age` in descending order.\n * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n */\nfunction orderBy(collection, iteratees, orders, guard) {\n  if (collection == null) {\n    return [];\n  }\n  if (!isArray(iteratees)) {\n    iteratees = iteratees == null ? [] : [iteratees];\n  }\n  orders = guard ? undefined : orders;\n  if (!isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n  return baseOrderBy(collection, iteratees, orders);\n}\n\nmodule.exports = orderBy;\n","var baseSet = require('./_baseSet');\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"names":["hiddenStyles","display","HiddenText","id","value","style","visuallyHidden","position","width","height","margin","border","padding","overflow","clip","clipPath","whiteSpace","LiveRegion","announcement","role","useAnnouncement","setAnnouncement","useState","announce","useCallback","baseClone","module","exports","CLONE_DEEP_FLAG","baseGetTag","isObjectLike","baseExtremum","baseGt","baseIteratee","array","iteratee","length","undefined","baseOrderBy","isArray","collection","iteratees","orders","guard","baseSet","object","path","baseUniq","Object","defineProperty","bottom","childrenEqual","a","b","_lodash","default","_react","Children","map","c","key","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","props","_ref3","verticalCompact","correctBounds","fastPositionEqual","left","top","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","num","setTopLeft","_ref2","concat","setTransform","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","initialLayout","children","cols","allowOverlap","layout","forEach","child","exists","String","push","isProduction","_grid","console","warn","g","validateLayout","_objectSpread","i","w","h","x","y","correctedLayout","withLayoutItem","itemKey","cb","item","_interopRequireDefault","obj","__esModule","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","target","arguments","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","DEBUG","bottomY","max","len","newLayout","Array","layoutItem","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","l1","l2","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","otherItem","fullLayout","compactH","Math","min","bounds","collidesWith","isUserAction","preventCollision","log","oldX","oldY","reverse","collisions","hasCollisions","collision","itemToMove","compactV","fakeItem","slice","sort","contextName","subProps","Error","j","_console"],"sourceRoot":""}