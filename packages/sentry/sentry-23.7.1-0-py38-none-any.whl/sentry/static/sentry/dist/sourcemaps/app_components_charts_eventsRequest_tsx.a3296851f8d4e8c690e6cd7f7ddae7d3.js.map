{"version":3,"file":"chunks/app_components_charts_eventsRequest_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/events.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/utils/getPeriod.tsx"],"sourcesContent":["import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {ApiResult, Client, ResponseMeta} from 'sentry/api';\nimport {canIncludePreviousPeriod} from 'sentry/components/charts/utils';\nimport {t} from 'sentry/locale';\nimport {\n  DateString,\n  EventsStats,\n  IssueAttachment,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'sentry/types';\nimport {LocationQuery} from 'sentry/utils/discover/eventView';\nimport {DiscoverDatasets} from 'sentry/utils/discover/types';\nimport {getPeriod} from 'sentry/utils/getPeriod';\nimport {PERFORMANCE_URL_PARAM} from 'sentry/utils/performance/constants';\nimport {QueryBatching} from 'sentry/utils/performance/contexts/genericQueryBatcher';\nimport {\n  ApiQueryKey,\n  getApiQueryData,\n  setApiQueryData,\n  useApiQuery,\n  UseApiQueryOptions,\n  useMutation,\n  UseMutationOptions,\n  useQueryClient,\n} from 'sentry/utils/queryClient';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\nimport useOrganization from 'sentry/utils/useOrganization';\n\ntype Options = {\n  organization: OrganizationSummary;\n  partial: boolean;\n  comparisonDelta?: number;\n  dataset?: DiscoverDatasets;\n  end?: DateString;\n  environment?: Readonly<string[]>;\n  excludeOther?: boolean;\n  field?: string[];\n  generatePathname?: (org: OrganizationSummary) => string;\n  includePrevious?: boolean;\n  interval?: string;\n  limit?: number;\n  orderby?: string;\n  period?: string | null;\n  project?: Readonly<number[]>;\n  query?: string;\n  queryBatching?: QueryBatching;\n  queryExtras?: Record<string, string>;\n  referrer?: string;\n  start?: DateString;\n  team?: Readonly<string | string[]>;\n  topEvents?: number;\n  useOnDemandMetrics?: boolean;\n  withoutZerofill?: boolean;\n  yAxis?: string | string[];\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {Boolean} options.excludeOther Exclude the \"Other\" series when making a topEvents query\n * @param {String[]} options.team List of teams to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Number} options.comparisonDelta Comparison delta for change alert event stats to include comparison stats\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n * @param {QueryBatching} options.queryBatching A container for batching functions from a provider\n * @param {Record<string, string>} options.queryExtras A list of extra query parameters\n * @param {(org: OrganizationSummary) => string} options.generatePathname A function that returns an override for the pathname\n */\nexport const doEventsRequest = <IncludeAllArgsType extends boolean = false>(\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    team,\n    period,\n    start,\n    end,\n    interval,\n    comparisonDelta,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n    partial,\n    withoutZerofill,\n    referrer,\n    queryBatching,\n    generatePathname,\n    queryExtras,\n    excludeOther,\n    includeAllArgs,\n    dataset,\n    useOnDemandMetrics,\n  }: {includeAllArgs?: IncludeAllArgsType} & Options\n): IncludeAllArgsType extends true\n  ? Promise<\n      [EventsStats | MultiSeriesEventsStats, string | undefined, ResponseMeta | undefined]\n    >\n  : Promise<EventsStats | MultiSeriesEventsStats> => {\n  const pathname =\n    generatePathname?.(organization) ??\n    `/organizations/${organization.slug}/events-stats/`;\n\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      comparisonDelta,\n      project,\n      environment,\n      team,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n      partial: partial ? '1' : undefined,\n      withoutZerofill: withoutZerofill ? '1' : undefined,\n      referrer: referrer ? referrer : 'api.organization-event-stats',\n      excludeOther: excludeOther ? '1' : undefined,\n      dataset,\n      useOnDemandMetrics,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  const queryObject = {\n    includeAllArgs,\n    query: {\n      ...urlQuery,\n      ...periodObj,\n      ...queryExtras,\n    },\n  };\n\n  if (queryBatching?.batchRequest) {\n    return queryBatching.batchRequest(api, pathname, queryObject);\n  }\n\n  return api.requestPromise<IncludeAllArgsType>(pathname, queryObject);\n};\n\nexport type EventQuery = {\n  field: string[];\n  query: string;\n  cursor?: string;\n  dataset?: DiscoverDatasets;\n  environment?: string[];\n  equation?: string[];\n  noPagination?: boolean;\n  per_page?: number;\n  project?: string | string[];\n  referrer?: string;\n  sort?: string | string[];\n  team?: string | string[];\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  url: LocationDescriptor;\n  value: string;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<ApiResult<Tag[]>> {\n  const urlParams = pick(query, [...Object.values(PERFORMANCE_URL_PARAM), 'cursor']);\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n    includeAllArgs: true,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport function fetchTotalCount(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(PERFORMANCE_URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n\ntype FetchEventAttachmentParameters = {\n  eventId: string;\n  orgSlug: string;\n  projectSlug: string;\n};\n\ntype FetchEventAttachmentResponse = IssueAttachment[];\n\nexport const makeFetchEventAttachmentsQueryKey = ({\n  orgSlug,\n  projectSlug,\n  eventId,\n}: FetchEventAttachmentParameters): ApiQueryKey => [\n  `/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/`,\n];\n\nexport const useFetchEventAttachments = (\n  {orgSlug, projectSlug, eventId}: FetchEventAttachmentParameters,\n  options: Partial<UseApiQueryOptions<FetchEventAttachmentResponse>> = {}\n) => {\n  const organization = useOrganization();\n  return useApiQuery<FetchEventAttachmentResponse>(\n    [`/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/`],\n    {\n      staleTime: Infinity,\n      ...options,\n      enabled:\n        (organization.features?.includes('event-attachments') ?? false) &&\n        options.enabled !== false,\n    }\n  );\n};\n\ntype DeleteEventAttachmentVariables = {\n  attachmentId: string;\n  eventId: string;\n  orgSlug: string;\n  projectSlug: string;\n};\n\ntype DeleteEventAttachmentResponse = unknown;\n\ntype DeleteEventAttachmentContext = {\n  previous?: IssueAttachment[];\n};\n\ntype DeleteEventAttachmentOptions = UseMutationOptions<\n  DeleteEventAttachmentResponse,\n  RequestError,\n  DeleteEventAttachmentVariables,\n  DeleteEventAttachmentContext\n>;\n\nexport const useDeleteEventAttachmentOptimistic = (\n  incomingOptions: Partial<DeleteEventAttachmentOptions> = {}\n) => {\n  const api = useApi({persistInFlight: true});\n  const queryClient = useQueryClient();\n\n  const options: DeleteEventAttachmentOptions = {\n    ...incomingOptions,\n    mutationFn: ({orgSlug, projectSlug, eventId, attachmentId}) => {\n      return api.requestPromise(\n        `/projects/${orgSlug}/${projectSlug}/events/${eventId}/attachments/${attachmentId}/`,\n        {method: 'DELETE'}\n      );\n    },\n    onMutate: async variables => {\n      await queryClient.cancelQueries(makeFetchEventAttachmentsQueryKey(variables));\n\n      const previous = getApiQueryData<FetchEventAttachmentResponse>(\n        queryClient,\n        makeFetchEventAttachmentsQueryKey(variables)\n      );\n\n      setApiQueryData<FetchEventAttachmentResponse>(\n        queryClient,\n        makeFetchEventAttachmentsQueryKey(variables),\n        oldData => {\n          if (!Array.isArray(oldData)) {\n            return oldData;\n          }\n\n          return oldData.filter(attachment => attachment?.id !== variables.attachmentId);\n        }\n      );\n\n      incomingOptions.onMutate?.(variables);\n\n      return {previous};\n    },\n    onError: (error, variables, context) => {\n      addErrorMessage(t('An error occurred while deleting the attachment'));\n\n      if (context) {\n        setApiQueryData(\n          queryClient,\n          makeFetchEventAttachmentsQueryKey(variables),\n          context.previous\n        );\n      }\n\n      incomingOptions.onError?.(error, variables, context);\n    },\n  };\n\n  return useMutation(options);\n};\n","import {PureComponent} from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'sentry/actionCreators/events';\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport LoadingPanel from 'sentry/components/charts/loadingPanel';\nimport {\n  canIncludePreviousPeriod,\n  getPreviousSeriesName,\n  isMultiSeriesStats,\n} from 'sentry/components/charts/utils';\nimport {t} from 'sentry/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'sentry/types';\nimport {Series, SeriesDataUnit} from 'sentry/types/echarts';\nimport {defined} from 'sentry/utils';\nimport {DURATION_UNITS, SIZE_UNITS} from 'sentry/utils/discover/fieldRenderers';\nimport {\n  AggregationOutputType,\n  getAggregateAlias,\n  stripEquationPrefix,\n} from 'sentry/utils/discover/fields';\nimport {DiscoverDatasets} from 'sentry/utils/discover/types';\nimport {QueryBatching} from 'sentry/utils/performance/contexts/genericQueryBatcher';\n\nexport type TimeSeriesData = {\n  allTimeseriesData?: EventsStatsData;\n  comparisonTimeseriesData?: Series[];\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  originalTimeseriesData?: EventsStatsData;\n  previousTimeseriesData?: Series[] | null;\n  timeAggregatedData?: Series | {};\n  timeframe?: {end: number; start: number};\n  // timeseries data\n  timeseriesData?: Series[];\n  timeseriesResultsTypes?: Record<string, AggregationOutputType>;\n  timeseriesTotals?: {count: number};\n  yAxis?: string | string[];\n};\n\ntype LoadingStatus = {\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  errorMessage?: string;\n};\n\n// Can hold additional data from the root an events stat object (eg. start, end, order, isMetricsData).\ninterface AdditionalSeriesInfo {\n  isMetricsData?: boolean;\n}\n\nexport type RenderProps = LoadingStatus &\n  TimeSeriesData & {\n    results?: Series[]; // Chart with multiple series.\n    seriesAdditionalInfo?: Record<string, AdditionalSeriesInfo>;\n  };\n\ntype DefaultProps = {\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Time delta for comparing intervals of alert metrics, in seconds\n   */\n  comparisonDelta?: number;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string | null;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  organization: OrganizationSummary;\n  /**\n   * Whether or not to include the last partial bucket. This happens for example when the\n   * current time is 11:26 and the last bucket ranges from 11:25-11:30. This means that\n   * the last bucket contains 1 minute worth of data while the rest contains 5 minutes.\n   *\n   * This flag indicates whether or not this last bucket should be included in the result.\n   */\n  partial: boolean;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n  /**\n   * Name used for display current series dataset tooltip\n   */\n  currentSeriesNames?: string[];\n  /**\n   * Optional callback to further process raw events request response data\n   */\n  dataLoadedCallback?: (any: EventsStats | MultiSeriesEventsStats | null) => void;\n  /**\n   * Specify the dataset to query from. Defaults to discover.\n   */\n  dataset?: DiscoverDatasets;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * Is query out of retention\n   */\n  expired?: boolean;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Allows overriding the pathname.\n   */\n  generatePathname?: (org: OrganizationSummary) => string;\n  /**\n   * Hide error toast (used for pages which also query discover). Stops error appearing as a toast.\n   */\n  hideError?: boolean;\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Query name used for displaying error toast if it is out of retention\n   */\n  name?: string;\n  /**\n   * A way to control error if error handling is not owned by the toast.\n   */\n  onError?: (error: string) => void;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  previousSeriesNames?: string[];\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * A container for query batching data and functions.\n   */\n  queryBatching?: QueryBatching;\n  /**\n   * Extra query parameters to be added.\n   */\n  queryExtras?: Record<string, string>;\n  /**\n   * A unique name for what's triggering this request, see organization_events_stats for an allowlist\n   */\n  referrer?: string;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * List of team ids to query\n   */\n  team?: Readonly<string | string[]>;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * Whether or not to use on demand metrics\n   * This is a temporary flag to allow us to test on demand metrics\n   */\n  useOnDemandMetrics?: boolean;\n  /**\n   * Whether or not to zerofill results\n   */\n  withoutZerofill?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n};\n\ninterface EventsRequestPropsWithTimeAggregation\n  extends DefaultProps,\n    EventsRequestPartialProps {\n  includeTimeAggregation: true;\n  timeAggregationSeriesName: string;\n}\n\ninterface EventsRequestPropsWithoutTimeAggregation\n  extends DefaultProps,\n    EventsRequestPartialProps {\n  includeTimeAggregation?: false;\n  timeAggregationSeriesName?: undefined;\n}\n\nexport type EventsRequestProps =\n  | EventsRequestPropsWithTimeAggregation\n  | EventsRequestPropsWithoutTimeAggregation;\n\ntype EventsRequestState = {\n  errored: boolean;\n  fetchedWithPrevious: boolean;\n  reloading: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  errorMessage?: string;\n};\n\nconst propNamesToIgnore = [\n  'api',\n  'children',\n  'organization',\n  'loading',\n  'queryBatching',\n  'generatePathname',\n];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    comparisonDelta: undefined,\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, onError, expired, name, hideError, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n      errorMessage: undefined,\n    }));\n\n    let errorMessage;\n    if (expired) {\n      errorMessage = t(\n        '%s has an invalid date range. Please try a more recent date range.',\n        name\n      );\n      addErrorMessage(errorMessage, {append: true});\n\n      this.setState({\n        errored: true,\n        errorMessage,\n      });\n    } else {\n      try {\n        api.clear();\n        timeseriesData = await doEventsRequest(api, props);\n      } catch (resp) {\n        if (resp && resp.responseJSON && resp.responseJSON.detail) {\n          errorMessage = resp.responseJSON.detail;\n        } else {\n          errorMessage = t('Error loading chart data');\n        }\n        if (!hideError) {\n          addErrorMessage(errorMessage);\n        }\n        if (onError) {\n          onError(errorMessage);\n        }\n        this.setState({\n          errored: true,\n          errorMessage,\n        });\n      }\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n    if (props.dataLoadedCallback) {\n      props.dataLoadedCallback(timeseriesData);\n    }\n  };\n\n  /**\n   * Retrieves dataset for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData = []\n  ): {current: EventsStatsData; previous: EventsStatsData | null} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null,\n    seriesName?: string\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: seriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n      stack: 'previous',\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(\n    data: EventsStatsData,\n    meta: EventsStats['meta'],\n    seriesName?: string\n  ): Series[] {\n    let scale = 1;\n    if (seriesName) {\n      const unit = meta?.units?.[getAggregateAlias(seriesName)];\n      // Scale series values to milliseconds or bytes depending on units from meta\n      scale = (unit && (DURATION_UNITS[unit] ?? SIZE_UNITS[unit])) ?? 1;\n    }\n\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0) * scale,\n        })),\n      },\n    ];\n  }\n\n  /**\n   * Transforms comparisonCount in query response into timeseries data to be used in a comparison chart for change alerts\n   */\n  transformComparisonTimeseriesData(data: EventsStatsData): Series[] {\n    return [\n      {\n        seriesName: 'comparisonCount()',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce(\n            (acc, {comparisonCount}) => acc + (comparisonCount ?? 0),\n            0\n          ),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats, seriesIndex: number = 0, seriesName?: string) {\n    const {data, isMetricsData, totals, meta} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n      currentSeriesNames,\n      previousSeriesNames,\n      comparisonDelta,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(\n          current,\n          meta,\n          seriesName ?? currentSeriesNames?.[seriesIndex]\n        )\n      : [];\n    const transformedComparisonData =\n      includeTransformedData && comparisonDelta\n        ? this.transformComparisonTimeseriesData(current)\n        : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(\n          current,\n          previous,\n          (seriesName ? getPreviousSeriesName(seriesName) : undefined) ??\n            previousSeriesNames?.[seriesIndex]\n        )\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    const timeframe =\n      response.start && response.end\n        ? !previous\n          ? {\n              start: response.start * 1000,\n              end: response.end * 1000,\n            }\n          : {\n              // Find the midpoint of start & end since previous includes 2x data\n              start: (response.start + response.end) * 500,\n              end: response.end * 1000,\n            }\n        : undefined;\n\n    const processedData = {\n      data: transformedData,\n      comparisonData: transformedComparisonData,\n      allData: data,\n      originalData: current,\n      totals,\n      isMetricsData,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n      timeframe,\n    };\n\n    return processedData;\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {topEvents, yAxis} = this.props;\n    const {timeseriesData, reloading, errored, errorMessage} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n    if (isMultiSeriesStats(timeseriesData, defined(topEvents))) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      let timeframe: {end: number; start: number} | undefined = undefined;\n      const seriesAdditionalInfo: Record<string, AdditionalSeriesInfo> = {};\n      const sortedTimeseriesData = Object.keys(timeseriesData)\n        .map(\n          (\n            seriesName: string,\n            index: number\n          ): [number, Series, Series | null, AdditionalSeriesInfo] => {\n            const seriesData: EventsStats = timeseriesData[seriesName];\n            const processedData = this.processData(\n              seriesData,\n              index,\n              stripEquationPrefix(seriesName)\n            );\n            if (!timeframe) {\n              timeframe = processedData.timeframe;\n            }\n            if (processedData.isMetricsData) {\n              seriesAdditionalInfo[seriesName] = {\n                isMetricsData: processedData.isMetricsData,\n              };\n            }\n            return [\n              seriesData.order || 0,\n              processedData.data[0],\n              processedData.previousData,\n              {isMetricsData: processedData.isMetricsData},\n            ];\n          }\n        )\n        .sort((a, b) => a[0] - b[0]);\n      const timeseriesResultsTypes: Record<string, AggregationOutputType> = {};\n      Object.keys(timeseriesData).forEach(key => {\n        const fieldsMeta = timeseriesData[key].meta?.fields[getAggregateAlias(key)];\n        if (fieldsMeta) {\n          timeseriesResultsTypes[key] = fieldsMeta;\n        }\n      });\n      const results: Series[] = sortedTimeseriesData.map(item => {\n        return item[1];\n      });\n      const previousTimeseriesData: Series[] | undefined = sortedTimeseriesData.some(\n        item => item[2] === null\n      )\n        ? undefined\n        : sortedTimeseriesData.map(item => {\n            return item[2] as Series;\n          });\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        results,\n        timeframe,\n        previousTimeseriesData,\n        seriesAdditionalInfo,\n        timeseriesResultsTypes,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    if (timeseriesData) {\n      const yAxisKey = yAxis && (typeof yAxis === 'string' ? yAxis : yAxis[0]);\n      const yAxisFieldType =\n        yAxisKey && timeseriesData.meta?.fields[getAggregateAlias(yAxisKey)];\n      const timeseriesResultsTypes = yAxisFieldType\n        ? {[yAxisKey]: yAxisFieldType}\n        : undefined;\n      const {\n        data: transformedTimeseriesData,\n        comparisonData: transformedComparisonTimeseriesData,\n        allData: allTimeseriesData,\n        originalData: originalTimeseriesData,\n        totals: timeseriesTotals,\n        originalPreviousData: originalPreviousTimeseriesData,\n        previousData: previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n        isMetricsData,\n      } = this.processData(timeseriesData);\n\n      const seriesAdditionalInfo = {\n        [this.props.currentSeriesNames?.[0] ?? 'current']: {isMetricsData},\n      };\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        // meta data,\n        seriesAdditionalInfo,\n        // timeseries data\n        timeseriesData: transformedTimeseriesData,\n        comparisonTimeseriesData: transformedComparisonTimeseriesData,\n        allTimeseriesData,\n        originalTimeseriesData,\n        timeseriesTotals,\n        originalPreviousTimeseriesData,\n        previousTimeseriesData: previousTimeseriesData\n          ? [previousTimeseriesData]\n          : previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n        timeseriesResultsTypes,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    return children({\n      loading,\n      reloading,\n      errored,\n      errorMessage,\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'sentry/constants';\nimport {DateString} from 'sentry/types';\nimport {getUtcDateString} from 'sentry/utils/dates';\n\ntype DateObject = {\n  /**\n   * Ending date object\n   */\n  end?: DateString;\n  /**\n   * Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n   */\n  period?: string | null;\n  /**\n   * Starting date object\n   */\n  start?: DateString;\n};\n\ntype Options = {\n  /**\n   * Doubles the given period (useful for getting previous period data)\n   */\n  shouldDoublePeriod?: boolean;\n};\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\nexport function getPeriod(\n  {period, start, end}: DateObject,\n  {shouldDoublePeriod}: Options = {}\n) {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/)!;\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n}\n"],"names":["doEventsRequest","api","_ref","organization","project","environment","team","period","start","end","interval","comparisonDelta","includePrevious","query","yAxis","field","topEvents","orderby","partial","withoutZerofill","referrer","queryBatching","generatePathname","queryExtras","excludeOther","includeAllArgs","dataset","useOnDemandMetrics","pathname","slug","shouldDoublePeriod","canIncludePreviousPeriod","queryObject","Object","fromEntries","entries","undefined","filter","_ref2","value","getPeriod","batchRequest","requestPromise","fetchTagFacets","orgSlug","queryOption","pick","values","PERFORMANCE_URL_PARAM","fetchTotalCount","then","res","count","makeFetchEventAttachmentsQueryKey","_ref3","projectSlug","eventId","useFetchEventAttachments","_ref4","options","arguments","length","useOrganization","useApiQuery","staleTime","Infinity","enabled","features","includes","useDeleteEventAttachmentOptimistic","incomingOptions","useApi","persistInFlight","queryClient","useQueryClient","mutationFn","_ref5","attachmentId","method","onMutate","async","cancelQueries","variables","previous","getApiQueryData","setApiQueryData","oldData","Array","isArray","attachment","id","onError","error","context","addErrorMessage","t","useMutation","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","EventsRequest","PureComponent","constructor","_this","this","_defineProperty","reloading","loading","errored","timeseriesData","fetchedWithPrevious","confirmedQuery","expired","name","hideError","errorMessage","setState","state","append","clear","resp","responseJSON","detail","unmounting","dataLoadedCallback","data","hasPreviousPeriod","dataMiddleIndex","Math","floor","current","slice","componentDidMount","fetchData","componentDidUpdate","prevProps","isEqual","componentWillUnmount","calculateTotalsPerTimestamp","getName","timestamp","map","i","countArray","reduce","acc","transformPreviousPeriodData","seriesName","_timestamp","_countArray","stack","transformAggregatedTimeseries","transformTimeseriesData","meta","scale","unit","units","getAggregateAlias","DURATION_UNITS","SIZE_UNITS","countsForTimestamp","transformComparisonTimeseriesData","_ref6","comparisonCount","processData","response","seriesIndex","isMetricsData","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","currentSeriesNames","previousSeriesNames","getData","comparisonData","allData","originalData","originalPreviousData","previousData","getPreviousSeriesName","timeAggregatedData","timeframe","render","children","showLoading","_jsx","LoadingPanel","isMultiSeriesStats","defined","seriesAdditionalInfo","sortedTimeseriesData","keys","index","seriesData","processedData","stripEquationPrefix","order","sort","a","b","timeseriesResultsTypes","forEach","fieldsMeta","fields","results","item","previousTimeseriesData","some","yAxisKey","yAxisFieldType","transformedTimeseriesData","transformedComparisonTimeseriesData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","comparisonTimeseriesData","displayName","limit","DEFAULT_STATS_PERIOD","statsPeriod","periodNumber","periodLength","match","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","moment","previousPeriodStart","subtract"],"sourceRoot":""}