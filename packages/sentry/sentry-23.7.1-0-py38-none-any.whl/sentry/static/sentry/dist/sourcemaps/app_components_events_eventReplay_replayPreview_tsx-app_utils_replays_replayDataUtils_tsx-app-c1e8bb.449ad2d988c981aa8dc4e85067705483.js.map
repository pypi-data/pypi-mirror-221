{"version":3,"file":"chunks/app_components_events_eventReplay_replayPreview_tsx-app_utils_replays_replayDataUtils_tsx-app-c1e8bb.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/events/eventReplay/replayPreview.tsx","webpack:///./app/components/replays/utils.tsx","webpack:///./app/utils/date/isValidDate.tsx","webpack:///./app/utils/getMinMax.tsx","webpack:///./app/utils/replays/replayDataUtils.tsx","webpack:///./app/utils/replays/types.tsx"],"sourcesContent":["import {useMemo} from 'react';\nimport styled from '@emotion/styled';\n\nimport {Alert} from 'sentry/components/alert';\nimport {Button} from 'sentry/components/button';\nimport ExternalLink from 'sentry/components/links/externalLink';\nimport List from 'sentry/components/list';\nimport ListItem from 'sentry/components/list/listItem';\nimport Placeholder from 'sentry/components/placeholder';\nimport {Provider as ReplayContextProvider} from 'sentry/components/replays/replayContext';\nimport ReplayPlayer from 'sentry/components/replays/replayPlayer';\nimport {relativeTimeInMs} from 'sentry/components/replays/utils';\nimport {IconPlay} from 'sentry/icons';\nimport {t, tct} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\nimport {Event} from 'sentry/types/event';\nimport getRouteStringFromRoutes from 'sentry/utils/getRouteStringFromRoutes';\nimport useReplayReader from 'sentry/utils/replays/hooks/useReplayReader';\nimport {useRoutes} from 'sentry/utils/useRoutes';\nimport {normalizeUrl} from 'sentry/utils/withDomainRequired';\nimport FluidHeight from 'sentry/views/replays/detail/layout/fluidHeight';\n\ntype Props = {\n  event: Event;\n  orgSlug: string;\n  replaySlug: string;\n  onClickOpenReplay?: () => void;\n};\n\nfunction ReplayPreview({orgSlug, replaySlug, event, onClickOpenReplay}: Props) {\n  const routes = useRoutes();\n  const {fetching, replay, replayRecord, fetchError, replayId} = useReplayReader({\n    orgSlug,\n    replaySlug,\n  });\n\n  const timeOfEvent = event.dateCreated ?? event.dateReceived;\n  const eventTimestamp = timeOfEvent\n    ? Math.floor(new Date(timeOfEvent).getTime() / 1000) * 1000\n    : 0;\n\n  const startTimestampMs = replayRecord?.started_at.getTime() ?? 0;\n\n  const initialTimeOffsetMs = useMemo(() => {\n    if (eventTimestamp && startTimestampMs) {\n      return relativeTimeInMs(eventTimestamp, startTimestampMs);\n    }\n\n    return 0;\n  }, [eventTimestamp, startTimestampMs]);\n\n  if (fetchError) {\n    const reasons = [\n      t('The replay was rate-limited and could not be accepted.'),\n      t('The replay has been deleted by a member in your organization.'),\n      t('There were network errors and the replay was not saved.'),\n      tct('[link:Read the docs] to understand why.', {\n        link: (\n          <ExternalLink href=\"https://docs.sentry.io/platforms/javascript/session-replay/#error-linking\" />\n        ),\n      }),\n    ];\n\n    return (\n      <Alert\n        type=\"info\"\n        showIcon\n        data-test-id=\"replay-error\"\n        trailingItems={\n          <Button\n            external\n            href=\"https://docs.sentry.io/platforms/javascript/session-replay/#error-linking\"\n            size=\"xs\"\n          >\n            {t('Read Docs')}\n          </Button>\n        }\n      >\n        <p>\n          {t(\n            'The replay for this event cannot be found. This could be due to these reasons:'\n          )}\n        </p>\n        <List symbol=\"bullet\">\n          {reasons.map((reason, i) => (\n            <ListItem key={i}>{reason}</ListItem>\n          ))}\n        </List>\n      </Alert>\n    );\n  }\n\n  if (fetching || !replayRecord) {\n    return (\n      <StyledPlaceholder\n        testId=\"replay-loading-placeholder\"\n        height=\"400px\"\n        width=\"100%\"\n      />\n    );\n  }\n\n  const fullReplayUrl = {\n    pathname: normalizeUrl(`/organizations/${orgSlug}/replays/${replayId}/`),\n    query: {\n      referrer: getRouteStringFromRoutes(routes),\n      t_main: 'console',\n      t: initialTimeOffsetMs / 1000,\n    },\n  };\n\n  return (\n    <ReplayContextProvider\n      isFetching={fetching}\n      replay={replay}\n      initialTimeOffsetMs={{offsetMs: initialTimeOffsetMs}}\n    >\n      <PlayerContainer data-test-id=\"player-container\">\n        <StaticPanel>\n          <ReplayPlayer isPreview />\n        </StaticPanel>\n        <CTAOverlay>\n          <Button\n            onClick={onClickOpenReplay}\n            icon={<IconPlay />}\n            priority=\"primary\"\n            to={fullReplayUrl}\n          >\n            {t('Open Replay')}\n          </Button>\n        </CTAOverlay>\n        <BadgeContainer>\n          <FeatureText>{t('Replays')}</FeatureText>\n        </BadgeContainer>\n      </PlayerContainer>\n    </ReplayContextProvider>\n  );\n}\n\nconst PlayerContainer = styled(FluidHeight)`\n  position: relative;\n  margin-bottom: ${space(2)};\n  background: ${p => p.theme.background};\n  gap: ${space(1)};\n  max-height: 448px;\n`;\n\nconst StaticPanel = styled(FluidHeight)`\n  border: 1px solid ${p => p.theme.border};\n  border-radius: ${p => p.theme.borderRadius};\n`;\n\nconst CTAOverlay = styled('div')`\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: rgba(255, 255, 255, 0.5);\n`;\n\nconst BadgeContainer = styled('div')`\n  display: flex;\n  align-items: center;\n  position: absolute;\n  top: ${space(1)};\n  right: ${space(1)};\n  background: ${p => p.theme.background};\n  border-radius: 2.25rem;\n  padding: ${space(0.75)} ${space(0.75)} ${space(0.75)} ${space(1)};\n  box-shadow: ${p => p.theme.dropShadowLight};\n  gap: 0 ${space(0.25)};\n`;\n\nconst FeatureText = styled('div')`\n  font-size: ${p => p.theme.fontSizeSmall};\n  line-height: 0;\n  color: ${p => p.theme.text};\n`;\n\nconst StyledPlaceholder = styled(Placeholder)`\n  margin-bottom: ${space(2)};\n`;\n\nexport default ReplayPreview;\n","import {formatSecondsToClock} from 'sentry/utils/formatters';\nimport type {ReplayFrame, SpanFrame} from 'sentry/utils/replays/types';\n\nconst SECOND = 1000;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\n\n/**\n * @param timestamp The timestamp that is our reference point. Can be anything that `moment` accepts such as `'2022-05-04T19:47:52.915000Z'` or `1651664872.915`\n * @param diffMs Number of milliseconds to adjust the timestamp by, either positive (future) or negative (past)\n * @returns Unix timestamp of the adjusted timestamp, in milliseconds\n */\nexport function relativeTimeInMs(\n  timestamp: ConstructorParameters<typeof Date>[0],\n  diffMs: number\n): number {\n  return Math.abs(new Date(timestamp).getTime() - diffMs);\n}\n\nexport function showPlayerTime(\n  timestamp: ConstructorParameters<typeof Date>[0],\n  relativeTimeMs: number,\n  showMs: boolean = false\n): string {\n  return formatTime(relativeTimeInMs(timestamp, relativeTimeMs), showMs);\n}\n\nexport function formatTime(ms: number, showMs?: boolean): string {\n  if (ms <= 0 || isNaN(ms)) {\n    if (showMs) {\n      return '00:00.000';\n    }\n\n    return '00:00';\n  }\n\n  const seconds = ms / 1000;\n  return formatSecondsToClock(showMs ? seconds : Math.floor(seconds));\n}\n\n/**\n * Figure out how many ticks to show in an area.\n * If there is more space available, we can show more granular ticks, but if\n * less space is available, fewer ticks.\n * Similarly if the duration is short, the ticks will represent a short amount\n * of time (like every second) but if the duration is long one tick may\n * represent an hour.\n *\n * @param durationMs The amount of time that we need to chop up into even sections\n * @param width Total width available, pixels\n * @param minWidth Minimum space for each column, pixels. Ex: So we can show formatted time like `1:00:00` between major ticks\n * @returns\n */\nexport function countColumns(durationMs: number, width: number, minWidth: number = 50) {\n  let maxCols = Math.floor(width / minWidth);\n  const remainder = durationMs - maxCols * width > 0 ? 1 : 0;\n  maxCols -= remainder;\n\n  // List of all the possible time granularities to display\n  // We could generate the list, which is basically a version of fizzbuzz, hard-coding is quicker.\n  const timeOptions = [\n    1 * HOUR,\n    30 * MINUTE,\n    20 * MINUTE,\n    15 * MINUTE,\n    10 * MINUTE,\n    5 * MINUTE,\n    2 * MINUTE,\n    1 * MINUTE,\n    30 * SECOND,\n    10 * SECOND,\n    5 * SECOND,\n    1 * SECOND,\n  ];\n\n  const timeBasedCols = timeOptions.reduce<Map<number, number>>((map, time) => {\n    map.set(time, Math.floor(durationMs / time));\n    return map;\n  }, new Map());\n\n  const [timespan, cols] = Array.from(timeBasedCols.entries())\n    .filter(([_span, c]) => c <= maxCols) // Filter for any valid timespan option where all ticks would fit\n    .reduce((best, next) => (next[1] > best[1] ? next : best), [0, 0]); // select the timespan option with the most ticks\n\n  const remaining = (durationMs - timespan * cols) / timespan;\n  return {timespan, cols, remaining};\n}\n\n/**\n * Group Crumbs for display along the timeline.\n *\n * The timeline is broken down into columns (aka buckets, or time-slices).\n * Columns translate to a fixed width on the screen, to prevent side-scrolling.\n *\n * This function groups crumbs into columns based on the number of columns available\n * and the timestamp of the crumb.\n */\nexport function getFramesByColumn(\n  durationMs: number,\n  frames: ReplayFrame[],\n  totalColumns: number\n) {\n  const safeDurationMs = isNaN(durationMs) ? 1 : durationMs;\n\n  const columnFramePairs = frames.map(frame => {\n    const columnPositionCalc =\n      Math.floor((frame.offsetMs / safeDurationMs) * (totalColumns - 1)) + 1;\n\n    // Should start at minimum in the first column\n    const column = Math.max(1, columnPositionCalc);\n\n    return [column, frame] as [number, ReplayFrame];\n  });\n\n  const framesByColumn = columnFramePairs.reduce<Map<number, ReplayFrame[]>>(\n    (map, [column, frame]) => {\n      if (map.has(column)) {\n        map.get(column)?.push(frame);\n      } else {\n        map.set(column, [frame]);\n      }\n      return map;\n    },\n    new Map()\n  );\n\n  return framesByColumn;\n}\n\ntype FlattenedSpanRange = {\n  /**\n   * Duration of this range\n   */\n  duration: number;\n  /**\n   * Absolute time in ms when the range ends\n   */\n  endTimestamp: number;\n  /**\n   * Number of spans that got flattened into this range\n   */\n  frameCount: number;\n  /**\n   * Absolute time in ms when the span starts\n   */\n  startTimestamp: number;\n};\n\nfunction doesOverlap(a: FlattenedSpanRange, b: FlattenedSpanRange) {\n  const bStartsWithinA =\n    a.startTimestamp <= b.startTimestamp && b.startTimestamp <= a.endTimestamp;\n  const bEndsWithinA =\n    a.startTimestamp <= b.endTimestamp && b.endTimestamp <= a.endTimestamp;\n  return bStartsWithinA || bEndsWithinA;\n}\n\nexport function flattenFrames(frames: SpanFrame[]): FlattenedSpanRange[] {\n  if (!frames.length) {\n    return [];\n  }\n\n  const [first, ...rest] = frames.map((span): FlattenedSpanRange => {\n    return {\n      frameCount: 1,\n      startTimestamp: span.timestampMs,\n      endTimestamp: span.endTimestampMs,\n      duration: span.endTimestampMs - span.timestampMs,\n    };\n  });\n\n  const flattened = [first];\n\n  for (const span of rest) {\n    let overlap = false;\n    for (const range of flattened) {\n      if (doesOverlap(range, span)) {\n        overlap = true;\n        range.frameCount += 1;\n        range.startTimestamp = Math.min(range.startTimestamp, span.startTimestamp);\n        range.endTimestamp = Math.max(range.endTimestamp, span.endTimestamp);\n        range.duration = range.endTimestamp - range.startTimestamp;\n        break;\n      }\n    }\n    if (!overlap) {\n      flattened.push(span);\n    }\n  }\n  return flattened;\n}\n\n/**\n * Divide two numbers safely\n */\nexport function divide(numerator: number, denominator: number | undefined) {\n  if (denominator === undefined || isNaN(denominator) || denominator === 0) {\n    return 0;\n  }\n  return numerator / denominator;\n}\n","/**\n * Check that a value is a valid Date object, that doesn't point to NaN\n *\n * https://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript\n */\nexport default function isValidDate(d: unknown): d is Date {\n  return d instanceof Date && !isNaN(d.getTime());\n}\n","/**\n * Calculate min/max of an array simultaneously.\n * This prevents two things:\n * - Avoid extra allocations and iterations, just loop through once.\n * - Avoid `Maximum call stack size exceeded` when the array is too large\n *   `Math.min()` & `Math.max()` will throw after about ~10‚Å∑ which is A LOT of items.\n *   See: https://stackoverflow.com/a/52613386\n *\n * `lodash.min()` & `lodash.max()` are also options, they use a while-loop as here,\n * but that also includes a comparator function which adds overhead.\n */\nexport default function getMinMax(arr: number[]) {\n  let len = arr.length;\n  let min = Infinity;\n  let max = -Infinity;\n\n  while (len--) {\n    min = arr[len] < min ? arr[len] : min;\n    max = arr[len] > max ? arr[len] : max;\n  }\n\n  return {min, max};\n}\n","import invariant from 'invariant';\nimport {duration} from 'moment';\n\nimport {transformCrumbs} from 'sentry/components/events/interfaces/breadcrumbs/utils';\nimport {t} from 'sentry/locale';\nimport type {\n  BreadcrumbTypeDefault,\n  BreadcrumbTypeInit,\n  BreadcrumbTypeNavigation,\n  Crumb,\n  RawCrumb,\n} from 'sentry/types/breadcrumbs';\nimport {BreadcrumbLevelType, BreadcrumbType} from 'sentry/types/breadcrumbs';\nimport isValidDate from 'sentry/utils/date/isValidDate';\nimport getMinMax from 'sentry/utils/getMinMax';\nimport type {\n  ReplayCrumb,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\nexport function mapResponseToReplayRecord(apiResponse: any): ReplayRecord {\n  // Marshal special fields into tags\n  const user = Object.fromEntries(\n    Object.entries(apiResponse.user)\n      .filter(([key, value]) => key !== 'display_name' && value)\n      .map(([key, value]) => [`user.${key}`, [value]])\n  );\n  const unorderedTags: ReplayRecord['tags'] = {\n    ...apiResponse.tags,\n    ...(apiResponse.browser?.name ? {'browser.name': [apiResponse.browser.name]} : {}),\n    ...(apiResponse.browser?.version\n      ? {'browser.version': [apiResponse.browser.version]}\n      : {}),\n    ...(apiResponse.device?.brand ? {'device.brand': [apiResponse.device.brand]} : {}),\n    ...(apiResponse.device?.family ? {'device.family': [apiResponse.device.family]} : {}),\n    ...(apiResponse.device?.model_id\n      ? {'device.model_id': [apiResponse.device.model_id]}\n      : {}),\n    ...(apiResponse.device?.name ? {'device.name': [apiResponse.device.name]} : {}),\n    ...(apiResponse.platform ? {platform: [apiResponse.platform]} : {}),\n    ...(apiResponse.releases ? {releases: [...apiResponse.releases]} : {}),\n    ...(apiResponse.replay_type ? {replayType: [apiResponse.replay_type]} : {}),\n    ...(apiResponse.os?.name ? {'os.name': [apiResponse.os.name]} : {}),\n    ...(apiResponse.os?.version ? {'os.version': [apiResponse.os.version]} : {}),\n    ...(apiResponse.sdk?.name ? {'sdk.name': [apiResponse.sdk.name]} : {}),\n    ...(apiResponse.sdk?.version ? {'sdk.version': [apiResponse.sdk.version]} : {}),\n    ...user,\n  };\n\n  // Sort the tags by key\n  const tags = Object.keys(unorderedTags)\n    .sort()\n    .reduce((acc, key) => {\n      acc[key] = unorderedTags[key];\n      return acc;\n    }, {});\n\n  const startedAt = new Date(apiResponse.started_at);\n  invariant(isValidDate(startedAt), 'replay.started_at is invalid');\n  const finishedAt = new Date(apiResponse.finished_at);\n  invariant(isValidDate(finishedAt), 'replay.finished_at is invalid');\n  return {\n    ...apiResponse,\n    ...(apiResponse.started_at ? {started_at: startedAt} : {}),\n    ...(apiResponse.finished_at ? {finished_at: finishedAt} : {}),\n    ...(apiResponse.duration !== undefined\n      ? {duration: duration(apiResponse.duration * 1000)}\n      : {}),\n    tags,\n  };\n}\n\nexport function breadcrumbFactory(\n  replayRecord: ReplayRecord,\n  errors: ReplayError[],\n  rawCrumbs: ReplayCrumb[],\n  spans: ReplaySpan[]\n): Crumb[] {\n  const UNWANTED_CRUMB_CATEGORIES = ['ui.focus', 'ui.blur'];\n\n  const initialUrl = replayRecord.urls?.[0] ?? replayRecord.tags.url?.join(', ');\n  const initBreadcrumb = {\n    type: BreadcrumbType.INIT,\n    timestamp: replayRecord.started_at.toISOString(),\n    level: BreadcrumbLevelType.INFO,\n    message: initialUrl,\n    data: {\n      action: 'replay-init',\n      label: t('Start recording'),\n      url: initialUrl,\n    },\n  } as BreadcrumbTypeInit;\n\n  const errorCrumbs: RawCrumb[] = errors.map(error => ({\n    type: BreadcrumbType.ERROR,\n    level: BreadcrumbLevelType.ERROR,\n    category: 'issue',\n    message: error.title,\n    data: {\n      label: error['error.type'].join(''),\n      eventId: error.id,\n      groupId: error['issue.id'] || 1,\n      groupShortId: error.issue,\n      project: error['project.name'],\n    },\n    timestamp: error.timestamp,\n  }));\n\n  const spanCrumbs: (BreadcrumbTypeDefault | BreadcrumbTypeNavigation)[] = spans\n    .filter(span =>\n      ['navigation.navigate', 'navigation.reload', 'largest-contentful-paint'].includes(\n        span.op\n      )\n    )\n    .sort((a, b) => a.startTimestamp - b.startTimestamp)\n    .map(span => {\n      if (span.op.startsWith('navigation')) {\n        const [, action] = span.op.split('.');\n        try {\n          return {\n            category: 'default',\n            type: BreadcrumbType.NAVIGATION,\n            timestamp: new Date(span.startTimestamp * 1000).toISOString(),\n            level: BreadcrumbLevelType.INFO,\n            message: span.description,\n            action,\n            data: {\n              to: span.description,\n              label:\n                action === 'reload'\n                  ? t('Reload')\n                  : action === 'navigate'\n                  ? t('Page load')\n                  : t('Navigation'),\n              ...span.data,\n            },\n          };\n        } catch {\n          return null;\n        }\n      }\n      try {\n        return {\n          type: BreadcrumbType.DEBUG,\n          timestamp: new Date(span.startTimestamp * 1000).toISOString(),\n          level: BreadcrumbLevelType.INFO,\n          category: 'default',\n          data: {\n            action: span.op,\n            ...span.data,\n            label: span.op === 'largest-contentful-paint' ? t('LCP') : span.op,\n          },\n        };\n      } catch {\n        return null;\n      }\n    })\n    .filter(Boolean) as (BreadcrumbTypeDefault | BreadcrumbTypeNavigation)[];\n\n  const hasPageLoad = spans.find(span => span.op === 'navigation.navigate');\n\n  const rawCrumbsWithTimestamp: RawCrumb[] = rawCrumbs\n    .filter(crumb => {\n      return (\n        !UNWANTED_CRUMB_CATEGORIES.includes(crumb.category || '') &&\n        // Explicitly include replay breadcrumbs to ensure we have valid UI for them\n        (!crumb.category?.startsWith('replay') ||\n          crumb.category === 'replay.mutations') &&\n        (crumb.category !== 'ui.slowClickDetected' ||\n          (crumb.data as Record<string, any>)?.timeAfterClickMs >= 3000)\n      );\n    })\n    .map(crumb => {\n      if (crumb.category === 'replay.mutations') {\n        const crumbData = crumb.data as Record<string, unknown>;\n        try {\n          return {\n            ...crumb,\n            type: crumbData.limit ? BreadcrumbType.ERROR : BreadcrumbType.WARNING,\n            level: crumbData.limit\n              ? BreadcrumbLevelType.FATAL\n              : BreadcrumbLevelType.WARNING,\n            timestamp: new Date(crumb.timestamp * 1000).toISOString(),\n          };\n        } catch {\n          return null;\n        }\n      }\n\n      try {\n        return {\n          ...crumb,\n          type: BreadcrumbType.DEFAULT,\n          timestamp: new Date(crumb.timestamp * 1000).toISOString(),\n        };\n      } catch {\n        return null;\n      }\n    })\n    .filter(Boolean) as RawCrumb[];\n\n  // TODO(replay): The important parts of transformCrumbs should be brought into\n  // here, we're hydrating our data and should have more control over the process.\n  const result = transformCrumbs([\n    ...(spans.length && !hasPageLoad ? [initBreadcrumb] : []),\n    ...rawCrumbsWithTimestamp,\n    ...errorCrumbs,\n    ...spanCrumbs,\n  ]);\n\n  return result.sort((a, b) => +new Date(a.timestamp || 0) - +new Date(b.timestamp || 0));\n}\n\nexport function spansFactory(spans: ReplaySpan[]) {\n  return spans\n    .sort((a, b) => a.startTimestamp - b.startTimestamp)\n    .map(span => ({\n      ...span,\n      id: `${span.description ?? span.op}-${span.startTimestamp}-${span.endTimestamp}`,\n      timestamp: span.startTimestamp * 1000,\n    }));\n}\n\n/**\n * We need to figure out the real start and end timestamps based on when\n * first and last bits of data were collected. In milliseconds.\n *\n * @deprecated Once the backend returns the corrected timestamps, this is not needed.\n */\nexport function replayTimestamps(\n  replayRecord: ReplayRecord,\n  rrwebEvents: {timestamp: number}[],\n  rawCrumbs: {timestamp: number}[],\n  rawSpanData: {endTimestamp: number; op: string; startTimestamp: number}[]\n) {\n  const rrwebTimestamps = rrwebEvents.map(event => event.timestamp).filter(Boolean);\n  const breadcrumbTimestamps = rawCrumbs\n    .map(rawCrumb => rawCrumb.timestamp)\n    .filter(Boolean);\n  const rawSpanDataFiltered = rawSpanData.filter(\n    ({op}) => op !== 'largest-contentful-paint'\n  );\n  const spanStartTimestamps = rawSpanDataFiltered.map(span => span.startTimestamp);\n  const spanEndTimestamps = rawSpanDataFiltered.map(span => span.endTimestamp);\n\n  // Calculate min/max of each array individually, to prevent extra allocations.\n  // Also using `getMinMax()` so we can handle any huge arrays.\n  const {min: minRRWeb, max: maxRRWeb} = getMinMax(rrwebTimestamps);\n  const {min: minCrumbs, max: maxCrumbs} = getMinMax(breadcrumbTimestamps);\n  const {min: minSpanStarts} = getMinMax(spanStartTimestamps);\n  const {max: maxSpanEnds} = getMinMax(spanEndTimestamps);\n\n  return {\n    startTimestampMs: Math.min(\n      replayRecord.started_at.getTime(),\n      minRRWeb,\n      minCrumbs * 1000,\n      minSpanStarts * 1000\n    ),\n    endTimestampMs: Math.max(\n      replayRecord.finished_at.getTime(),\n      maxRRWeb,\n      maxCrumbs * 1000,\n      maxSpanEnds * 1000\n    ),\n  };\n}\n","import type {eventWithTime as TEventWithTime} from '@sentry-internal/rrweb';\n\nexport type {serializedNodeWithId} from '@sentry-internal/rrweb-snapshot';\nexport type {fullSnapshotEvent} from '@sentry-internal/rrweb';\n\nexport {NodeType} from '@sentry-internal/rrweb-snapshot';\nexport {EventType} from '@sentry-internal/rrweb';\n\nimport type {\n  BreadcrumbFrame as TRawBreadcrumbFrame,\n  BreadcrumbFrameEvent as TBreadcrumbFrameEvent,\n  OptionFrameEvent as TOptionFrameEvent,\n  SpanFrame as TRawSpanFrame,\n  SpanFrameEvent as TSpanFrameEvent,\n} from '@sentry/replay';\nimport invariant from 'invariant';\n\n/**\n * Extra breadcrumb types not included in `@sentry/replay`\n */\ntype ExtraBreadcrumbTypes = {\n  category: 'navigation';\n  data: {\n    from: string;\n    to: string;\n  };\n  message: string;\n  timestamp: number;\n  type: string; // For compatibility reasons\n};\n\nexport type RawBreadcrumbFrame = TRawBreadcrumbFrame | ExtraBreadcrumbTypes;\nexport type BreadcrumbFrameEvent = TBreadcrumbFrameEvent;\nexport type RecordingFrame = TEventWithTime;\nexport type OptionFrame = TOptionFrameEvent['data']['payload'];\nexport type OptionFrameEvent = TOptionFrameEvent;\nexport type RawSpanFrame = TRawSpanFrame;\nexport type SpanFrameEvent = TSpanFrameEvent;\n\nexport function isRecordingFrame(\n  attachment: Record<string, any>\n): attachment is RecordingFrame {\n  return 'type' in attachment && 'timestamp' in attachment;\n}\n\nexport function isBreadcrumbFrameEvent(\n  attachment: Record<string, any>\n): attachment is BreadcrumbFrameEvent {\n  return attachment.data?.tag === 'breadcrumb';\n}\n\nexport function isSpanFrameEvent(\n  attachment: Record<string, any>\n): attachment is SpanFrameEvent {\n  return attachment.data?.tag === 'performanceSpan';\n}\n\nexport function isOptionFrameEvent(\n  attachment: Record<string, any>\n): attachment is TOptionFrameEvent {\n  return attachment.data?.tag === 'options';\n}\n\nexport function isBreadcrumbFrame(\n  frame: ReplayFrame | undefined\n): frame is BreadcrumbFrame {\n  return Boolean(frame && 'category' in frame && frame.category !== 'issue');\n}\n\nexport function isSpanFrame(frame: ReplayFrame | undefined): frame is SpanFrame {\n  return Boolean(frame && 'op' in frame);\n}\n\nexport function isErrorFrame(frame: ReplayFrame | undefined): frame is ErrorFrame {\n  return Boolean(frame && 'category' in frame && frame.category === 'issue');\n}\n\nexport function getFrameOpOrCategory(frame: ReplayFrame) {\n  const val = ('op' in frame && frame.op) || ('category' in frame && frame.category);\n  invariant(val, 'Frame has no category or op');\n  return val;\n}\n\nexport function isDeadClick(frame: SlowClickFrame) {\n  return frame.data.endReason === 'timeout';\n}\n\nexport function isDeadRageClick(frame: SlowClickFrame) {\n  return Boolean(\n    isDeadClick(frame) && frame.data.clickCount && frame.data.clickCount >= 5\n  );\n}\n\nexport function isRageClick(frame: MultiClickFrame) {\n  return frame.data.clickCount >= 5;\n}\n\ntype Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;\n\ntype HydratedTimestamp = {\n  /**\n   * The difference in timestamp and replay.started_at, in millieseconds\n   */\n  offsetMs: number;\n  /**\n   * The Date when the breadcrumb happened\n   */\n  timestamp: Date;\n  /**\n   * Alias of timestamp, in milliseconds\n   */\n  timestampMs: number;\n};\ntype HydratedBreadcrumb<Category extends string> = Overwrite<\n  Extract<TRawBreadcrumbFrame | ExtraBreadcrumbTypes, {category: Category}>,\n  HydratedTimestamp\n>;\n\ntype HydratedStartEndDate = {\n  /**\n   * The end Date of the span\n   */\n  endTimestamp: Date;\n  /**\n   * Alias of endTimestamp, in milliseconds\n   */\n  endTimestampMs: number;\n  /**\n   * The difference in startTimestamp and replay.started_at, in millieseconds\n   */\n  offsetMs: number;\n  /**\n   * The start Date of the span\n   *\n   * See also timestampMs\n   */\n  startTimestamp: Date;\n  /**\n   * Alias of startTimestamp, in milliseconds\n   *\n   * Included to make sorting with `HydratedBreadcrumb` easier\n   */\n  timestampMs: number;\n};\ntype HydratedSpan<Op extends string> = Overwrite<\n  Extract<TRawSpanFrame, {op: Op}>,\n  HydratedStartEndDate // TODO: do we need `{id:string}` added too?\n>;\n\n// Breadcrumbs\nexport type BreadcrumbFrame = Overwrite<\n  TRawBreadcrumbFrame | ExtraBreadcrumbTypes,\n  HydratedTimestamp\n>;\nexport type BlurFrame = HydratedBreadcrumb<'ui.blur'>;\nexport type ClickFrame = HydratedBreadcrumb<'ui.click'>;\nexport type ConsoleFrame = HydratedBreadcrumb<'console'>;\nexport type FocusFrame = HydratedBreadcrumb<'ui.focus'>;\nexport type InputFrame = HydratedBreadcrumb<'ui.input'>;\nexport type KeyboardEventFrame = HydratedBreadcrumb<'ui.keyDown'>;\nexport type MultiClickFrame = HydratedBreadcrumb<'ui.multiClick'>;\nexport type MutationFrame = HydratedBreadcrumb<'replay.mutations'>;\nexport type NavFrame = HydratedBreadcrumb<'navigation'>;\nexport type SlowClickFrame = HydratedBreadcrumb<'ui.slowClickDetected'>;\n\n// This list should match each of the categories used in `HydratedBreadcrumb` above.\nexport const BreadcrumbCategories = [\n  'console',\n  'ui.click',\n  'ui.input',\n  'replay.mutations',\n  'ui.keyDown',\n  'ui.blur',\n  'ui.focus',\n  'ui.slowClickDetected',\n  'ui.multiClick',\n];\n\n// Spans\nexport type SpanFrame = Overwrite<TRawSpanFrame, HydratedStartEndDate>;\nexport type HistoryFrame = HydratedSpan<'navigation.push'>;\nexport type LargestContentfulPaintFrame = HydratedSpan<'largest-contentful-paint'>;\nexport type MemoryFrame = HydratedSpan<'memory'>;\nexport type NavigationFrame = HydratedSpan<\n  'navigation.navigate' | 'navigation.reload' | 'navigation.back_forward'\n>;\nexport type PaintFrame = HydratedSpan<'paint'>;\nexport type RequestFrame = HydratedSpan<'resource.fetch' | 'resource.xhr'>;\nexport type ResourceFrame = HydratedSpan<\n  | 'resource.css'\n  | 'resource.iframe'\n  | 'resource.img'\n  | 'resource.link'\n  | 'resource.other'\n  | 'resource.script'\n>;\n\n// This list should match each of the operations used in `HydratedSpan` above.\nexport const SpanOps = [\n  'navigation.push',\n  'largest-contentful-paint',\n  'memory',\n  'navigation.navigate',\n  'navigation.reload',\n  'navigation.back_forward',\n  'paint',\n  'resource.fetch',\n  'resource.xhr',\n  'resource.css',\n  'resource.iframe',\n  'resource.img',\n  'resource.link',\n  'resource.other',\n  'resource.script',\n];\n\n/**\n * This is a result of a custom discover query\n */\nexport type RawReplayError = {\n  ['error.type']: string[];\n  // ['error.value']: string[]; // deprecated, use title instead. See organization_replay_events_meta.py\n  id: string;\n  issue: string;\n  ['issue.id']: number;\n  ['project.name']: string;\n  timestamp: string;\n  title: string;\n};\n\nexport type ErrorFrame = Overwrite<\n  BreadcrumbFrame,\n  {\n    category: 'issue';\n    data: {\n      eventId: string;\n      groupId: number;\n      groupShortId: string;\n      label: string;\n      labels: string[];\n      projectSlug: string;\n    };\n    message: string;\n  }\n>;\n\nexport type ReplayFrame = BreadcrumbFrame | ErrorFrame | SpanFrame;\n"],"names":["ReplayPreview","_ref","orgSlug","replaySlug","event","onClickOpenReplay","routes","useRoutes","fetching","replay","replayRecord","fetchError","replayId","useReplayReader","timeOfEvent","dateCreated","dateReceived","eventTimestamp","Math","floor","Date","getTime","startTimestampMs","started_at","initialTimeOffsetMs","useMemo","relativeTimeInMs","reasons","t","tct","link","_jsx","ExternalLink","href","_jsxs","Alert","type","showIcon","trailingItems","Button","external","size","children","List","symbol","map","reason","i","ListItem","StyledPlaceholder","testId","height","width","fullReplayUrl","pathname","normalizeUrl","query","referrer","getRouteStringFromRoutes","t_main","ReplayContextProvider","isFetching","offsetMs","PlayerContainer","StaticPanel","ReplayPlayer","isPreview","CTAOverlay","onClick","icon","IconPlay","priority","to","BadgeContainer","FeatureText","displayName","_styled","FluidHeight","target","space","p","theme","background","border","borderRadius","name","styles","dropShadowLight","fontSizeSmall","text","Placeholder","SECOND","MINUTE","HOUR","timestamp","diffMs","abs","showPlayerTime","relativeTimeMs","showMs","arguments","length","undefined","formatTime","ms","isNaN","seconds","formatSecondsToClock","countColumns","durationMs","minWidth","maxCols","timeBasedCols","reduce","time","set","Map","timespan","cols","Array","from","entries","filter","_span","c","best","next","remaining","getFramesByColumn","frames","totalColumns","safeDurationMs","frame","columnPositionCalc","max","_ref2","column","has","get","push","doesOverlap","a","b","bStartsWithinA","startTimestamp","endTimestamp","bEndsWithinA","flattenFrames","first","rest","span","frameCount","timestampMs","endTimestampMs","duration","flattened","overlap","range","min","divide","numerator","denominator","isValidDate","d","getMinMax","arr","len","Infinity","mapResponseToReplayRecord","apiResponse","user","Object","fromEntries","key","value","unorderedTags","tags","browser","version","device","brand","family","model_id","platform","releases","replay_type","replayType","os","sdk","keys","sort","acc","startedAt","invariant","finishedAt","finished_at","breadcrumbFactory","errors","rawCrumbs","spans","UNWANTED_CRUMB_CATEGORIES","initialUrl","urls","url","join","initBreadcrumb","BreadcrumbType","INIT","toISOString","level","BreadcrumbLevelType","INFO","message","data","action","label","errorCrumbs","error","ERROR","category","title","eventId","id","groupId","groupShortId","issue","project","spanCrumbs","includes","op","startsWith","split","NAVIGATION","description","DEBUG","Boolean","hasPageLoad","find","rawCrumbsWithTimestamp","crumb","timeAfterClickMs","crumbData","limit","WARNING","FATAL","DEFAULT","transformCrumbs","spansFactory","replayTimestamps","rrwebEvents","rawSpanData","rrwebTimestamps","breadcrumbTimestamps","rawCrumb","rawSpanDataFiltered","_ref3","spanStartTimestamps","spanEndTimestamps","minRRWeb","maxRRWeb","minCrumbs","maxCrumbs","minSpanStarts","maxSpanEnds","isRecordingFrame","attachment","isBreadcrumbFrameEvent","tag","isSpanFrameEvent","isOptionFrameEvent","isBreadcrumbFrame","isSpanFrame","isErrorFrame","getFrameOpOrCategory","val","isDeadClick","endReason","isDeadRageClick","clickCount","isRageClick"],"sourceRoot":""}