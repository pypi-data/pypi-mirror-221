"""Load all user defined config and env vars."""

import logging
import os
import argparse
from pydantic import BaseModel, Extra
from typing import List
from .const import *

class PathConfig(BaseModel):
    input: str = DEFAULT_INPUT_PATH
    output: str = DEFAULT_OUT_PATH

class ModelConfig(BaseModel):
    modelName: str = DEFAULT_MODEL_NAME
    dimensions: int = DEFAULT_DIMENSIONS
    workers: int = DEFAULT_WORKERS
    epochs: int = DEFAULT_EPOCHS
    min_count: int = DEFAULT_MIN_COUNT
    wl_iterations: int = DEFAULT_WL_ITERATIONS
    learning_rate: float = DEFAULT_LEARNING_RATE
    down_sampling: float = DEFAULT_DOWN_SAMPLING
    judge: int = DEFAULT_JUDGE

class FolderConfig(BaseModel, extra=Extra.allow):
    dataset: str = DATASET_DIR
    feature: str = FEATURE_DIR
    vectorize: str = VECTORIZE_DIR
    model: str = MODEL_DIR
    predict: str = PREDICT_DIR
    folder_list: List[str] = [DATASET_DIR, FEATURE_DIR, VECTORIZE_DIR, MODEL_DIR, PREDICT_DIR]

    def __iter__(self):
        return FolderClassIter(self.folder_list)

    def set_folder(self, __name: str, __value: str):
        if hasattr(self, __name):
            raise AttributeError(f"Folder {__name} already exists.")
        else:
            __value = f"./{__value}/"
            setattr(self, __name, __value)
            self.folder_list.append(__value)

    def del_folder(self, __name: str):
        if hasattr(self, __name):
            __value = getattr(self, __name)
            delattr(self, __name)
            if __value in self.folder_list:
                self.folder_list.remove(__value)

class FolderClassIter(object):
    def __init__(self, folder_list):
        self._folder = folder_list
        self._folder_size = len(folder_list)
        self._current_index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self._current_index < self._folder_size:
            member = self._folder[self._current_index]
            self._current_index += 1
            return member
        raise StopIteration

class Config(BaseModel):
    """The blueprint for detector's whole config."""

    # pylint: disable=too-few-public-
    path: PathConfig = PathConfig()
    folder: FolderConfig = FolderConfig()
    model: ModelConfig = ModelConfig()
    classify: bool = DEFAULT_CLASSIFY

def parameter_parser(config: Config) -> Config:
        """
        A method to parse up command line parameters.
        By default it gives an embedding of the partial NCI1 graph dataset.
        The default hyperparameters give a good quality representation without grid search.
        Representations are sorted by ID.
        """
        parser = argparse.ArgumentParser(description="Run Graph2Vec.")

        parser.add_argument("--input-path","-i",
                            dest="input_path",
                            nargs="?",
                            default=DEFAULT_INPUT_PATH,
                            help="Input folder with jsons."
                            )

        parser.add_argument("--output-path","-o",
                            dest="output_path",
                            nargs="?",
                            default=DEFAULT_OUT_PATH,
                            help="Embeddings path."
                            )

        parser.add_argument("--dimensions",
                            dest="dimensions",
                            type=int,
                            default=DEFAULT_DIMENSIONS,
                            help="Number of dimensions. Default is 128."
                            )

        parser.add_argument("--workers",
                            dest="workers",
                            type=int,
                            default=DEFAULT_WORKERS,
                            help="Number of workers. Default is 4."
                            )

        parser.add_argument("--epochs",
                            dest="epochs",
                            type=int,
                            default=DEFAULT_EPOCHS,
                            help="Number of epochs. Default is 10."
                            )

        parser.add_argument("--min-count",
                            dest="min_count",
                            type=int,
                            default=DEFAULT_MIN_COUNT,
                            help="Minimal structural feature count. Default is 5."
                            )

        parser.add_argument("--wl-iterations",
                            dest="wl_iterations",
                            type=int,
                            default=DEFAULT_WL_ITERATIONS,
                            help="Number of Weisfeiler-Lehman iterations. Default is 2."
                            )

        parser.add_argument("--learning-rate",
                            dest="learning_rate",
                            type=float,
                            default=DEFAULT_LEARNING_RATE,
                            help="Initial learning rate. Default is 0.025."
                            )

        parser.add_argument("--down-sampling",
                            dest="down_sampling",
                            type=float,
                            default=DEFAULT_DOWN_SAMPLING,
                            help="Down sampling rate of features. Default is 0.0001."
                            )

        parser.add_argument("--judge",
                            dest="judge",
                            type=int,
                            default=DEFAULT_JUDGE,
                            help="Rename?"
                            )

        parser.add_argument('--model','-m',
                            dest="model",
                            nargs='?',
                            default=DEFAULT_MODEL_NAME,
                            help='Select the model(KNN,LR,MLP,RF,SVM).'
                            )

        parser.add_argument('--classify', '-c',
                            dest="classify",
                            action='store_true',
                            help='apply the family classifier'
                            )
        args = parser.parse_args()
        if hasattr(args, 'input_path'):
            config.path.input = args.input_path
        if hasattr(args, 'output_path'):
            config.path.output = args.output_path
        if hasattr(args, 'dimensions'):
            config.model.dimensions = args.dimensions
        if hasattr(args, 'workers'):
            config.model.workers = args.workers
        if hasattr(args, 'epochs'):
            config.model.epochs = args.epochs
        if hasattr(args, 'min_count'):
            config.model.min_count = args.min_count
        if hasattr(args, 'wl_iterations'):
            config.model.wl_iterations = args.wl_iterations
        if hasattr(args, 'learning_rate'):
            config.model.learning_rate = args.learning_rate
        if hasattr(args, 'down_sampling'):
            config.model.down_sampling = args.down_sampling
        if hasattr(args, 'judge'):
            config.model.judge = args.judge
        if hasattr(args, 'model'):
            config.model.modelName = args.model
        if hasattr(args, 'classify'):
            config.classify = args.classify

        # return parser.parse_args()
        return config

def write_config_to_file(config: Config):
    with open(CONFIG_FILE_NAME, "w", encoding="utf8") as file:
        file.write(config.json())

def detect_config_file(argparse: bool=False) -> None:
    if argparse:
        logging.info(
            "Creating local config file by argparse."
        )
        write_config_to_file(parameter_parser(Config()))
        logging.info(f"{CONFIG_FILE_NAME} created!")
    elif CONFIG_FILE_NAME in os.listdir():
        logging.info(f"{CONFIG_FILE_NAME} detected!")
    else:
        logging.info(
            "config file not found. creating local config file by default config."
        )
        write_config_to_file(Config())
        logging.info(f"{CONFIG_FILE_NAME} created!")

def read_config(count=1) -> Config:
    """Load the configuration defined by user."""
    if count > 3:
        logging.warning("Failed to read config, returning default config")
        return Config()
    if count != 1:
        logging.info(f"Trying to read config time:{count}")
    try:
        with open(CONFIG_FILE_NAME, encoding="utf8") as file:
            return Config.parse_raw(file.read())
        # else:
        #     return Config()
    except Exception as err:
        logging.warning(err)
        detect_config_file(argparse=False)
        return read_config(count=count+1)

detect_config_file(argparse=True)
CONFIG = read_config()

logging.info("config.py got executed")