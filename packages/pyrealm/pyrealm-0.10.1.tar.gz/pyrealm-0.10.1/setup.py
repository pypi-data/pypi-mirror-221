# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pyrealm', 'pyrealm.constants', 'pyrealm.pmodel', 'pyrealm_build_data']

package_data = \
{'': ['*']}

install_requires = \
['Bottleneck>=1.3.5,<2.0.0',
 'dacite>=1.6.0,<2.0.0',
 'numpy>=1.16.5,<2.0.0',
 'scipy>=1.7.3,<2.0.0',
 'tabulate>=0.8.10,<0.9.0']

setup_kwargs = {
    'name': 'pyrealm',
    'version': '0.10.1',
    'description': 'Python implementations of REALM models',
    'long_description': '# The `pyrealm` package\n\nThese are development notes for the package, user documentation can be found at:\n\n[](https://pyrealm.readthedocs.io/)\n\n## Overview\n\nThis a Python 3 package intended to provide a common framework for a number of\nrelated models of plant productivity, growth and demography.\n\n## Code development\n\n### Package managment\n\nThe package uses `poetry` to manage dependencies, generate virtual environments for code\ndevelopment and then for package building and publication. You will need to install\n`poetry` to develop the code.\n\n### Source code management\n\nThe codebase is developed in `git` with a repository at:\n\n[](https://github.com/davidorme/pyrealm)\n\nIt uses the `git flow` model for development and release. Briefly:\n\n* All code development should happen specific `feature/feature_name` branches.\n* Pull requests (PR) should be made to merge feature branches into the `develop` branch.\n* Candidate release versions should be made on specific `release/x.y.z` branches\n  and these are then committed to the `master` branch only after final checking.\n* The `master` branch should only ever contain commits representing new release\n  versions - do not work on the `master` branch.\n\nBoth the `develop` and `master` branches are protected on GitHub to avoid accidents!\n\n### Code quality\n\nThe project uses the `pre-commit` tool to enforce code quality. The configuration file\n`.pre-commit-config.yaml` shows the details of the tool chain, but `isort`, `black`,\n`flake8` and `markdownlint` are used to maintain code quality. You will need to install\n`pre-commit` to develop package code, and each PR must pass the same set of checks.\n\n### Code testing\n\n#### Using `doctest`\n\nThe package docstrings contain `doctest` examples of code use. These are intended to\ndemonstrate use and to validate a reference set of inputs against expected outputs. They\ndo not provide extensive unit testing! To run the docstring tests, use:\n\n```bash\npython -m doctest pyrealm/pmodel.py\npython -m doctest pyrealm/*.py\n```\n\nFor `doctest` on warnings, see the example for `pyrealm.utilities.convert_rh_to_vpd`\nwhich redirects the stderr to stdout to allow for the warning text to be included in the\ndoctest.\n\n#### Using `pytest`\n\nThe `test` directory contains `pytest` modules to provide greater testing of different\ninput combinations and to check errors are raised correctly. These are the main tests\nthat the package is behaving as expected.\n\n```bash\npytest\n```\n\n### Continuous integration\n\nThe project uses continuous integration via GitHub Actions to check that the package is\nbuilding correctly and that both `doctest` and `pytest` tests are passing. The status of\nbuilds can be seen at:\n\n[](https://github.com/davidorme/pyrealm/actions)\n\n## Documentation\n\nThe `pyrealm` package is documented using `sphinx`, with source material in the\n`docs/source` directory.\n\nThe documentation in `source` uses [Myst\nMarkdown](https://myst-parser.readthedocs.io/en/latest/) rather than the standard\n`sphinx` reStructuredText (`.rst`) format. This is because the documentation uses the\n`myst_nb` extension to `sphinx` that supports running documentation as a Jupyter\nnotebook: the built documentation includes examples of running code and output plots to\ndemonstrate the use and behaviour of the package.\n\nThe `sphinx` configuration includes the `sphinx.ext.mathjax` extension to support\nmathematical notation. This has been configured to also load the `mhchem` extension,\nsupporting the rendering of chemical notation.\n\n### Docstrings\n\nThe module codes uses docstrings written in the [Google\nstyle](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html).\nUnlike the main documentation pages, the docstrings in code are written using\nreStructuredText because the `autodoc` functions in `sphinx` currently rely on `rst`\ninputs. This allows the function documentation to be stored alongside the code and\nincluded simply into the documentation.\n\n### Building the documentation\n\nAdditional python packages given in `docs/source/requirements.txt` are needed to build\nthe documentation. To actually build the documentation, use `make` in the package root,\nwhich will use the `Makefile` created by `sphinx-quickstart`.\n\n```bash\ncd docs\nmake html\n```\n\n### Online documentation\n\nThe documentation for the package is hosted at:\n\n[](https://pyrealm.readthedocs.io/en/develop/pmodel.html)\n\nThis has been configured to build commits to the `master` branch, which should\ngenerate version specific sets of documentation.\n\n### Referencing\n\nThe documentation uses the `sphinxcontrib-bibtex` package to support citations.\nThis uses Latex like citation keys in the documentation to insert references and\nbuild a bibliography. The reference library in `source/refs.bib` needs to be\nkept up to date with the literature for the project. The `sphinx_astrorefs` package is\nused to provide an Author Date style citation format.\n\n## Release process\n\nReleasing a new version of the package follows the flow below:\n\n1. Create a `release` branch from `develop` containing the new release code.\n2. Check that this branch builds correctly, that the documentation builds correctly and\n   that the package publishes to the `test-pypi` repository.\n3. When all is well, create pull requests on GitHub to merge the `release` branch into\n   both `develop` and `master`, along with a version tag for the release.\n4. Once you have updated your local repository, then the tag can be used to build and\n   publish the final version to the main PyPi site.\n\nIt is easier if `git` is configured to push new tags along with commits. This\nessentially just means that new releases can be sent with a single commit. This only\nneeds to be set once.\n\n```bash\nset git config --global push.followTags true\n```\n\n### Create the release branch\n\nUsing `git flow` commands as an example to create a new release:\n\n```sh\ngit flow release start new_release\n```\n\nObviously, use something specific, not `new_release`! Ideally, you would do a dry run of\nthe next step and use the version - but it should be fairly obvious what this will be!\n\nThe `poetry version` command can then be used to bump the version number. Note that the\ncommand needs a \'bump rule\', which sets which part of the semantic version number to\nincrement (`major`, `minor` or `patch`). For example:\n\n```sh\npoetry version patch\n```\n\nThis updates `pyproject.toml`. At present, the package is set up so that you also *have\nto update the version number in `pyrealm/version.py`* to match manually.\n\n### Publish and test the release branch\n\nWith those changes committed, publish the release branch:\n\n```sh\ngit commit -m "Version bump" pyrealm/version.py\ngit flow release publish new_release\n```\n\nThe GitHub Actions will then ensure that the code passes quality assurance and then runs\nthe test suites on a range of Python versions and operating systems.\n\n### Check package publication\n\nThe `sdist` and `wheel` builds for the package can then be built locally using `poetry`\n\n```bash\npoetry build\n```\n\nThe first time this is run, `poetry` needs to be configured to add the Test PyPi\nrepository and an API token from that site. Note that accounts are not shared between\nthe Test and main PyPi sites: the API token for `test-pypi` is different from\n`pypi` and you have to log in to each system separately and generate a token on each.\n\n```sh\npoetry config repositories.test-pypi https://test.pypi.org/legacy/\npoetry config pypi-token.test-pypi <your-token>\n```\n\nThe built packages can then be published to `test-pypi` using:\n\n```sh\npoetry publish -r test-pypi\n```\n\n### Check the documentation builds\n\nLog in to:\n\n[](https://readthedocs.org)\n\nwhich is the admin site controlling the build process. From the Versions tab, activate\nthe `release/new_release` branch and wait for it to build. Check the Builds tab to see\nthat it has built successfully and maybe check updates! If it has built succesfully, do\ncheck pages to make sure that page code has executed successfully, and then go back to\nthe Versions tab and deactivate and hide the branch.\n\n### Create pull requests into `master` and `develop`\n\nIf all is well, then two PRs need to be made on GitHub:\n\n* The `release` branch into `master`, to bring all commits since the last release and\n  any fixes on release into `master`.\n* The `release` branch into `develop`, to bring any `release` fixes back into `develop`.\n\nOnce both of those have been merged, the `feature` branch can be deleted.\n\n### Tag, build and publish\n\nOnce the `origin` repository is merged, then use `git pull` to bring `develop` and\n`master` up to date on a local repo. Then, create a tag using the release version.\n\n```sh\ngit checkout master\ngit tag <version>\ngit push --tags\n```\n\nThe final commit on `master` is now tagged with the release version. You can add tags on\nthe GitHub website, but only by using the GitHub release system and we are using PyPi to\ndistribute package releases.\n\nBefore publishing a package to the main PyPi site for the first time, you need to set an\nAPI token for PyPi.\n\n```sh\npoetry config pypi-token.pypi <your-token>\n```\n\nAnd now you can build the packages from `master` and publish.\n\n```sh\npoetry build\npoetry publish\n```\n',
    'author': 'David Orme',
    'author_email': 'd.orme@imperial.ac.uk',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://pyrealm.readthedocs.io/',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<3.11',
}


setup(**setup_kwargs)
