# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/iiif.ipynb.

# %% auto 0
__all__ = ['Rectangle']

# %% ../nbs/iiif.ipynb 3
import numpy as np
from xml.dom.minidom import parseString
from svg.path import parse_path
import cv2
import numpy as np
from svg.path import parse_path
from xml.dom.minidom import parseString
import matplotlib.pyplot as plt
import svgwrite
import json

# %% ../nbs/iiif.ipynb 4
class Rectangle:

    def extract_points_from_svg(self, svg_content):
        doc = parseString(svg_content)
        path_strings = [path.getAttribute('d') for path in doc.getElementsByTagName('path')]
        points = []
        num_points_on_curve = 100
        for path_string in path_strings:
            path = parse_path(path_string)
            for e in path:
                if e.__class__.__name__ in ['Line', 'Move']:
                    points.append([e.start.real, e.start.imag])
                    points.append([e.end.real, e.end.imag])
                elif e.__class__.__name__ == 'CubicBezier':
                    t_values = np.linspace(0, 1, num_points_on_curve)
                    for t in t_values:
                        point = e.point(t)
                        points.append([point.real, point.imag])
                # Add more cases for other types of commands if needed
        return np.array(points, dtype=np.float32)

    def compute_minimum_area_rectangle(self, points):
        rect = cv2.minAreaRect(points)
        center = rect[0]
        angle = rect[2]
        width = rect[1][0]
        height = rect[1][1]
        return center, angle, width, height

    def plot_bounding_box(self, points, box):
        plt.figure()
        for i in range(4):
            p1 = box[i]
            p2 = box[(i+1)%4]
            plt.plot([p1[0], p2[0]], [p1[1], p2[1]], 'r-')
        plt.plot(points[:, 0], points[:, 1], 'b.')
        plt.show()

    def create_svg_with_rectangle(self, center, angle, width, height):
        dwg = svgwrite.Drawing(profile='tiny')
        
        angle_rad = -1 * -1 * angle * np.pi / 180.0  # -angle to match SVG rotation direction


        rotation_matrix = np.array([
            [np.cos(angle_rad), -np.sin(angle_rad)],
            [np.sin(angle_rad), np.cos(angle_rad)]
        ])
        rect_points = np.array([
            [-width / 2, -height / 2],
            [width / 2, -height / 2],
            [width / 2, height / 2],
            [-width / 2, height / 2]
        ])
        rotated_points = (rotation_matrix @ rect_points.T).T + center

        # Create path using M and L commands
        path = dwg.path(d=f"M {rotated_points[0][0]} {rotated_points[0][1]} ", fill='none', stroke='black')
        for point in rotated_points[1:]:
            path.push(f"L {point[0]} {point[1]} ")
        path.push("Z")  # Close the path
        dwg.add(path)

        return dwg # .tostring()
    
    def convert_from_svg_str(self, svg):
        points = self.extract_points_from_svg(svg)

        center, angle, width, height = self.compute_minimum_area_rectangle(points)

        svg_content = self.create_svg_with_rectangle(center, angle, width, height)

        return svg_content.tostring()

    def convert(self, path, opath):
        with open(path, 'r') as f:
            manifest_data = json.load(f)

        canvases = manifest_data['items']

        for canvas in canvases:
            annotations = canvas["annotations"][0]["items"]

            for annotation in annotations:
                target = annotation["target"]

                if "selector" in target and target["selector"]["type"] == "SvgSelector":
                    value = target["selector"]["value"]

                    svg_content = value

                    points = self.extract_points_from_svg(svg_content)

                    center, angle, width, height = self.compute_minimum_area_rectangle(points)

                    svg_content2 = self.create_svg_with_rectangle(center, angle, width, height)

                    target["selector"]["value"] = svg_content2.tostring()

        with open(opath, 'w') as f:
            json.dump(manifest_data, f, indent=2)
