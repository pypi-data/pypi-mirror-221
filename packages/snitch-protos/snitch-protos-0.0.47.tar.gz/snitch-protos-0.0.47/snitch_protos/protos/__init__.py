# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: common.proto, external_api.proto, internal_api.proto, pipeline.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from . import steps


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ResponseCode(betterproto.Enum):
    """Common status codes used in gRPC method responses"""

    RESPONSE_CODE_UNSET = 0
    RESPONSE_CODE_OK = 1
    RESPONSE_CODE_BAD_REQUEST = 2
    RESPONSE_CODE_NOT_FOUND = 3
    RESPONSE_CODE_INTERNAL_SERVER_ERROR = 4
    RESPONSE_CODE_GENERIC_ERROR = 5


class WasmExitCode(betterproto.Enum):
    """
    Included in WASM response; SDK is responsible for interpreting the response
    status and how it relates to the step condition. ie. WASM func returns
    WASM_EXIT_CODE_INTERNAL_ERROR lookup ON_ERROR conditions to determine what
    to do next. ie. WASM func returns WASM_EXIT_CODE_SUCCESS lookup ON_MATCH
    conditions to determine what to do next;
    """

    WASM_EXIT_CODE_UNSET = 0
    WASM_EXIT_CODE_SUCCESS = 1
    WASM_EXIT_CODE_FAILURE = 2
    WASM_EXIT_CODE_INTERNAL_ERROR = 3


class PipelineStepCondition(betterproto.Enum):
    """
    A condition defines how the SDK should handle a step response -- should it
    continue executing the pipeline, should it abort, should it notify the
    server? Each step can have multiple conditions.
    """

    CONDITION_UNSET = 0
    CONDITION_CONTINUE = 1
    CONDITION_ABORT = 2
    CONDITION_NOTIFY = 3


class CommandType(betterproto.Enum):
    """Types of commands that can be sent to the SDK"""

    SNITCH_COMMAND_TYPE_UNSET = 0
    SNITCH_COMMAND_TYPE_KEEPALIVE = 1
    SNITCH_COMMAND_TYPE_SET_PIPELINE = 2
    SNITCH_COMMAND_TYPE_DELETE_PIPELINE = 3
    SNITCH_COMMAND_TYPE_PAUSE_PIPELINE = 4
    SNITCH_COMMAND_TYPE_UNPAUSE_PIPELINE = 5


class OperationType(betterproto.Enum):
    OPERATION_TYPE_UNSET = 0
    OPERATION_TYPE_CONSUMER = 1
    OPERATION_TYPE_PRODUCER = 2


@dataclass(eq=False, repr=False)
class StandardResponse(betterproto.Message):
    """Common response message for many gRPC methods"""

    id: str = betterproto.string_field(1)
    """Co-relation ID for the request / response"""

    code: "ResponseCode" = betterproto.enum_field(2)
    message: str = betterproto.string_field(3)
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Debug info that server may populate with additional info."""


@dataclass(eq=False, repr=False)
class GetServicesRequest(betterproto.Message):
    """protolint:disable INDENT"""

    pass


@dataclass(eq=False, repr=False)
class GetServicesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetServiceRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetServiceResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetPipelinesRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetPipelinesResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetPipelineRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetPipelineResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetPipelineRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetPipelineResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeletePipelineRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeletePipelineResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetStepsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GetStepsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CreateStepRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CreateStepResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UpdateStepRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UpdateStepResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteStepRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteStepResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TestRequest(betterproto.Message):
    input: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class TestResponse(betterproto.Message):
    output: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class WasmRequest(betterproto.Message):
    """SDK generates a WASM request and passes this to the WASM func"""

    step: "PipelineStep" = betterproto.message_field(1)
    input: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class WasmResponse(betterproto.Message):
    """Returned by all WASM functions"""

    output: bytes = betterproto.bytes_field(1)
    exit_code: "WasmExitCode" = betterproto.enum_field(2)
    exit_msg: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PipelineStep(betterproto.Message):
    """
    A PipelineCommand consists of one or more pipeline steps. A pipeline step
    is an immutable set of instructions on how to execute a step. The SDK will
    use the pipeline step to generate a WASM request.
    """

    id: str = betterproto.string_field(1)
    """Unique ID for the step"""

    name: str = betterproto.string_field(2)
    """Friendly name for the step"""

    conditions: List["PipelineStepCondition"] = betterproto.enum_field(3)
    """Conditions that SDK should check before executing next step"""

    detective: "steps.DetectiveStep" = betterproto.message_field(1000, group="step")
    transform: "steps.TransformStep" = betterproto.message_field(1001, group="step")
    encode: "steps.EncodeStep" = betterproto.message_field(1002, group="step")
    decode: "steps.DecodeStep" = betterproto.message_field(1003, group="step")
    custom: "steps.CustomStep" = betterproto.message_field(1004, group="step")
    wasm_id: str = betterproto.string_field(10000)
    """WASM module ID (set by backend)"""

    wasm_bytes: bytes = betterproto.bytes_field(10001)
    """WASM module bytes (set by backend)"""

    wasm_function: str = betterproto.string_field(10002)
    """WASM function name to execute (set by backend)"""


@dataclass(eq=False, repr=False)
class SetPipelineCommand(betterproto.Message):
    """Used for both Add and Update"""

    id: str = betterproto.string_field(1)
    """Unique ID for the pipeline"""

    name: str = betterproto.string_field(2)
    """Friendly name for the pipeline"""

    steps: List["PipelineStep"] = betterproto.message_field(3)
    """One or more steps to execute"""


@dataclass(eq=False, repr=False)
class DeletePipelineCommand(betterproto.Message):
    id: str = betterproto.string_field(1)
    """Unique ID for the pipeline"""


@dataclass(eq=False, repr=False)
class PausePipelineCommand(betterproto.Message):
    id: str = betterproto.string_field(1)
    """Unique ID for the pipeline"""


@dataclass(eq=False, repr=False)
class UnpausePipelineCommand(betterproto.Message):
    id: str = betterproto.string_field(1)
    """Unique ID for the pipeline"""


@dataclass(eq=False, repr=False)
class HeartbeatRequest(betterproto.Message):
    """
    Each consumer and producer should send periodic heartbeats to the server to
    let the server know that they are still active.
    """

    audience: "Audience" = betterproto.message_field(1)
    last_activity_unix_timestamp_utc: int = betterproto.int64_field(2)
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class NotifyRequest(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    rule_name: str = betterproto.string_field(2)
    audience: "Audience" = betterproto.message_field(3)
    occurred_at_unix_ts_utc: int = betterproto.int64_field(4)
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class MetricsRequest(betterproto.Message):
    rule_id: str = betterproto.string_field(1)
    rule_name: str = betterproto.string_field(2)
    audience: "Audience" = betterproto.message_field(3)
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class RegisterRequest(betterproto.Message):
    service_name: str = betterproto.string_field(1)
    dry_run: bool = betterproto.bool_field(2)
    """
    If set, we know that any pipelines or steps executed in this SDK will NOT
    modify the input/output data. As in, the SDK will log what it _would_ do
    and always return the original data set.
    """

    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """snitch-server uses this under the hood for debug"""


@dataclass(eq=False, repr=False)
class DeregisterRequest(betterproto.Message):
    """
    Same as RegisterRequest - used for broadcasting a deregistration event
    """

    service_name: str = betterproto.string_field(1)
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class BusEvent(betterproto.Message):
    """Type used by `snitch-server` for sending messages on its local bus."""

    request_id: str = betterproto.string_field(1)
    source: str = betterproto.string_field(2)
    command_response: "CommandResponse" = betterproto.message_field(100, group="event")
    register_request: "RegisterRequest" = betterproto.message_field(101, group="event")
    deregister_request: "DeregisterRequest" = betterproto.message_field(
        102, group="event"
    )
    heartbeat_request: "HeartbeatRequest" = betterproto.message_field(
        103, group="event"
    )
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class CommandResponse(betterproto.Message):
    """
    The primary method to send commands to the SDK; server will send zero or
    more RegisterResponse's with SetPipelineRequest on SDK instantiation.
    """

    audience: "Audience" = betterproto.message_field(1)
    """Who is this command intended for?"""

    set_pipeline: "SetPipelineCommand" = betterproto.message_field(100, group="command")
    delete_pipeline: "DeletePipelineCommand" = betterproto.message_field(
        101, group="command"
    )
    pause_pipeline: "PausePipelineCommand" = betterproto.message_field(
        102, group="command"
    )
    unpause_pipeline: "UnpausePipelineCommand" = betterproto.message_field(
        103, group="command"
    )
    metadata: Dict[str, str] = betterproto.map_field(
        1000, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class Audience(betterproto.Message):
    """Used to indicate who a request/command is intended for"""

    service_name: str = betterproto.string_field(1)
    """Name of the service"""

    component_name: str = betterproto.string_field(2)
    """
    Name of the component the SDK is interacting with (ie. kafka-$topic-name)
    """

    operation_type: "OperationType" = betterproto.enum_field(3)
    """Consumer or Producer"""


class ExternalStub(betterproto.ServiceStub):
    async def get_services(
        self,
        get_services_request: "GetServicesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetServicesResponse":
        return await self._unary_unary(
            "/protos.External/GetServices",
            get_services_request,
            GetServicesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_service(
        self,
        get_service_request: "GetServiceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetServiceResponse":
        return await self._unary_unary(
            "/protos.External/GetService",
            get_service_request,
            GetServiceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_pipelines(
        self,
        get_pipelines_request: "GetPipelinesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetPipelinesResponse":
        return await self._unary_unary(
            "/protos.External/GetPipelines",
            get_pipelines_request,
            GetPipelinesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_pipeline(
        self,
        get_pipeline_request: "GetPipelineRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetPipelineResponse":
        return await self._unary_unary(
            "/protos.External/GetPipeline",
            get_pipeline_request,
            GetPipelineResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_pipeline(
        self,
        set_pipeline_request: "SetPipelineRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetPipelineResponse":
        return await self._unary_unary(
            "/protos.External/SetPipeline",
            set_pipeline_request,
            SetPipelineResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_pipeline(
        self,
        delete_pipeline_request: "DeletePipelineRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeletePipelineResponse":
        return await self._unary_unary(
            "/protos.External/DeletePipeline",
            delete_pipeline_request,
            DeletePipelineResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_steps(
        self,
        get_steps_request: "GetStepsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetStepsResponse":
        return await self._unary_unary(
            "/protos.External/GetSteps",
            get_steps_request,
            GetStepsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_step(
        self,
        create_step_request: "CreateStepRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateStepResponse":
        return await self._unary_unary(
            "/protos.External/CreateStep",
            create_step_request,
            CreateStepResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_step(
        self,
        update_step_request: "UpdateStepRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateStepResponse":
        return await self._unary_unary(
            "/protos.External/UpdateStep",
            update_step_request,
            UpdateStepResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_step(
        self,
        delete_step_request: "DeleteStepRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteStepResponse":
        return await self._unary_unary(
            "/protos.External/DeleteStep",
            delete_step_request,
            DeleteStepResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def test(
        self,
        test_request: "TestRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TestResponse":
        return await self._unary_unary(
            "/protos.External/Test",
            test_request,
            TestResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class InternalStub(betterproto.ServiceStub):
    async def register(
        self,
        register_request: "RegisterRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["CommandResponse"]:
        async for response in self._unary_stream(
            "/protos.Internal/Register",
            register_request,
            CommandResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def heartbeat(
        self,
        heartbeat_request: "HeartbeatRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StandardResponse":
        return await self._unary_unary(
            "/protos.Internal/Heartbeat",
            heartbeat_request,
            StandardResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def notify(
        self,
        notify_request: "NotifyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StandardResponse":
        return await self._unary_unary(
            "/protos.Internal/Notify",
            notify_request,
            StandardResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def metrics(
        self,
        metrics_request: "MetricsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StandardResponse":
        return await self._unary_unary(
            "/protos.Internal/Metrics",
            metrics_request,
            StandardResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ExternalBase(ServiceBase):
    async def get_services(
        self, get_services_request: "GetServicesRequest"
    ) -> "GetServicesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_service(
        self, get_service_request: "GetServiceRequest"
    ) -> "GetServiceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_pipelines(
        self, get_pipelines_request: "GetPipelinesRequest"
    ) -> "GetPipelinesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_pipeline(
        self, get_pipeline_request: "GetPipelineRequest"
    ) -> "GetPipelineResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_pipeline(
        self, set_pipeline_request: "SetPipelineRequest"
    ) -> "SetPipelineResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_pipeline(
        self, delete_pipeline_request: "DeletePipelineRequest"
    ) -> "DeletePipelineResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_steps(
        self, get_steps_request: "GetStepsRequest"
    ) -> "GetStepsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_step(
        self, create_step_request: "CreateStepRequest"
    ) -> "CreateStepResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_step(
        self, update_step_request: "UpdateStepRequest"
    ) -> "UpdateStepResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_step(
        self, delete_step_request: "DeleteStepRequest"
    ) -> "DeleteStepResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def test(self, test_request: "TestRequest") -> "TestResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_services(
        self, stream: "grpclib.server.Stream[GetServicesRequest, GetServicesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_services(request)
        await stream.send_message(response)

    async def __rpc_get_service(
        self, stream: "grpclib.server.Stream[GetServiceRequest, GetServiceResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_service(request)
        await stream.send_message(response)

    async def __rpc_get_pipelines(
        self, stream: "grpclib.server.Stream[GetPipelinesRequest, GetPipelinesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_pipelines(request)
        await stream.send_message(response)

    async def __rpc_get_pipeline(
        self, stream: "grpclib.server.Stream[GetPipelineRequest, GetPipelineResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_pipeline(request)
        await stream.send_message(response)

    async def __rpc_set_pipeline(
        self, stream: "grpclib.server.Stream[SetPipelineRequest, SetPipelineResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_pipeline(request)
        await stream.send_message(response)

    async def __rpc_delete_pipeline(
        self,
        stream: "grpclib.server.Stream[DeletePipelineRequest, DeletePipelineResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_pipeline(request)
        await stream.send_message(response)

    async def __rpc_get_steps(
        self, stream: "grpclib.server.Stream[GetStepsRequest, GetStepsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_steps(request)
        await stream.send_message(response)

    async def __rpc_create_step(
        self, stream: "grpclib.server.Stream[CreateStepRequest, CreateStepResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_step(request)
        await stream.send_message(response)

    async def __rpc_update_step(
        self, stream: "grpclib.server.Stream[UpdateStepRequest, UpdateStepResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_step(request)
        await stream.send_message(response)

    async def __rpc_delete_step(
        self, stream: "grpclib.server.Stream[DeleteStepRequest, DeleteStepResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_step(request)
        await stream.send_message(response)

    async def __rpc_test(
        self, stream: "grpclib.server.Stream[TestRequest, TestResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.test(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/protos.External/GetServices": grpclib.const.Handler(
                self.__rpc_get_services,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetServicesRequest,
                GetServicesResponse,
            ),
            "/protos.External/GetService": grpclib.const.Handler(
                self.__rpc_get_service,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetServiceRequest,
                GetServiceResponse,
            ),
            "/protos.External/GetPipelines": grpclib.const.Handler(
                self.__rpc_get_pipelines,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetPipelinesRequest,
                GetPipelinesResponse,
            ),
            "/protos.External/GetPipeline": grpclib.const.Handler(
                self.__rpc_get_pipeline,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetPipelineRequest,
                GetPipelineResponse,
            ),
            "/protos.External/SetPipeline": grpclib.const.Handler(
                self.__rpc_set_pipeline,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetPipelineRequest,
                SetPipelineResponse,
            ),
            "/protos.External/DeletePipeline": grpclib.const.Handler(
                self.__rpc_delete_pipeline,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeletePipelineRequest,
                DeletePipelineResponse,
            ),
            "/protos.External/GetSteps": grpclib.const.Handler(
                self.__rpc_get_steps,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetStepsRequest,
                GetStepsResponse,
            ),
            "/protos.External/CreateStep": grpclib.const.Handler(
                self.__rpc_create_step,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateStepRequest,
                CreateStepResponse,
            ),
            "/protos.External/UpdateStep": grpclib.const.Handler(
                self.__rpc_update_step,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateStepRequest,
                UpdateStepResponse,
            ),
            "/protos.External/DeleteStep": grpclib.const.Handler(
                self.__rpc_delete_step,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteStepRequest,
                DeleteStepResponse,
            ),
            "/protos.External/Test": grpclib.const.Handler(
                self.__rpc_test,
                grpclib.const.Cardinality.UNARY_UNARY,
                TestRequest,
                TestResponse,
            ),
        }


class InternalBase(ServiceBase):
    async def register(
        self, register_request: "RegisterRequest"
    ) -> AsyncIterator["CommandResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield CommandResponse()

    async def heartbeat(
        self, heartbeat_request: "HeartbeatRequest"
    ) -> "StandardResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def notify(self, notify_request: "NotifyRequest") -> "StandardResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def metrics(self, metrics_request: "MetricsRequest") -> "StandardResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_register(
        self, stream: "grpclib.server.Stream[RegisterRequest, CommandResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.register,
            stream,
            request,
        )

    async def __rpc_heartbeat(
        self, stream: "grpclib.server.Stream[HeartbeatRequest, StandardResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.heartbeat(request)
        await stream.send_message(response)

    async def __rpc_notify(
        self, stream: "grpclib.server.Stream[NotifyRequest, StandardResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.notify(request)
        await stream.send_message(response)

    async def __rpc_metrics(
        self, stream: "grpclib.server.Stream[MetricsRequest, StandardResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.metrics(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/protos.Internal/Register": grpclib.const.Handler(
                self.__rpc_register,
                grpclib.const.Cardinality.UNARY_STREAM,
                RegisterRequest,
                CommandResponse,
            ),
            "/protos.Internal/Heartbeat": grpclib.const.Handler(
                self.__rpc_heartbeat,
                grpclib.const.Cardinality.UNARY_UNARY,
                HeartbeatRequest,
                StandardResponse,
            ),
            "/protos.Internal/Notify": grpclib.const.Handler(
                self.__rpc_notify,
                grpclib.const.Cardinality.UNARY_UNARY,
                NotifyRequest,
                StandardResponse,
            ),
            "/protos.Internal/Metrics": grpclib.const.Handler(
                self.__rpc_metrics,
                grpclib.const.Cardinality.UNARY_UNARY,
                MetricsRequest,
                StandardResponse,
            ),
        }
