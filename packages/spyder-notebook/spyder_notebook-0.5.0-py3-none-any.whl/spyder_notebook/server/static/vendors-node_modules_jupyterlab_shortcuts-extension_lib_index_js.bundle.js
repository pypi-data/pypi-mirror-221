"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_shortcuts-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ErrorObject\": () => (/* binding */ ErrorObject),\n/* harmony export */   \"ShortcutInput\": () => (/* binding */ ShortcutInput),\n/* harmony export */   \"ShortcutObject\": () => (/* binding */ ShortcutObject),\n/* harmony export */   \"TakenByObject\": () => (/* binding */ TakenByObject)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/keyboard */ \"webpack/sharing/consume/default/@lumino/keyboard/@lumino/keyboard\");\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n/** Object for shortcut items */\nclass ShortcutObject {\n    constructor() {\n        this.commandName = '';\n        this.label = '';\n        this.keys = {};\n        this.source = '';\n        this.selector = '';\n        this.category = '';\n        this.id = '';\n        this.numberOfShortcuts = 0;\n        this.hasConflict = false;\n    }\n    get(sortCriteria) {\n        if (sortCriteria === 'label') {\n            return this.label;\n        }\n        else if (sortCriteria === 'selector') {\n            return this.selector;\n        }\n        else if (sortCriteria === 'category') {\n            return this.category;\n        }\n        else if (sortCriteria === 'source') {\n            return this.source;\n        }\n        else {\n            return '';\n        }\n    }\n}\n/** Object for conflicting shortcut error messages */\nclass ErrorObject extends ShortcutObject {\n    constructor() {\n        super();\n        this.takenBy = new TakenByObject();\n    }\n}\n/** Object for showing which shortcut conflicts with the new one */\nclass TakenByObject {\n    constructor(shortcut) {\n        if (shortcut) {\n            this.takenBy = shortcut;\n            this.takenByKey = '';\n            this.takenByLabel = shortcut.category + ': ' + shortcut.label;\n            this.id = shortcut.commandName + '_' + shortcut.selector;\n        }\n        else {\n            this.takenBy = new ShortcutObject();\n            this.takenByKey = '';\n            this.takenByLabel = '';\n            this.id = '';\n        }\n    }\n}\nclass ShortcutInput extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        super(props);\n        this.handleUpdate = () => {\n            let keys = this.state.keys;\n            keys.push(this.state.currentChain);\n            this.setState({ keys: keys });\n            this.props.handleUpdate(this.props.shortcut, this.state.keys);\n        };\n        this.handleOverwrite = async () => {\n            this.props\n                .deleteShortcut(this.state.takenByObject.takenBy, this.state.takenByObject.takenByKey)\n                .then(this.handleUpdate());\n        };\n        this.handleReplace = async () => {\n            let keys = this.state.keys;\n            keys.push(this.state.currentChain);\n            this.props.toggleInput();\n            await this.props.deleteShortcut(this.props.shortcut, this.props.shortcutId);\n            this.props.handleUpdate(this.props.shortcut, keys);\n        };\n        /** Parse user input for chained shortcuts */\n        this.parseChaining = (event, value, userInput, keys, currentChain) => {\n            let key = _lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.EN_US.keyForKeydownEvent(event.nativeEvent);\n            const modKeys = ['Shift', 'Control', 'Alt', 'Meta', 'Ctrl', 'Accel'];\n            if (event.key === 'Backspace') {\n                userInput = '';\n                value = '';\n                keys = [];\n                currentChain = '';\n                this.setState({\n                    value: value,\n                    userInput: userInput,\n                    keys: keys,\n                    currentChain: currentChain\n                });\n            }\n            else if (event.key !== 'CapsLock') {\n                const lastKey = userInput\n                    .substr(userInput.lastIndexOf(' ') + 1, userInput.length)\n                    .trim();\n                /** if last key was not a modefier then there is a chain */\n                if (modKeys.lastIndexOf(lastKey) === -1 && lastKey != '') {\n                    userInput = userInput + ',';\n                    keys.push(currentChain);\n                    currentChain = '';\n                    /** check if a modefier key was held down through chain */\n                    if (event.ctrlKey && event.key != 'Control') {\n                        userInput = (userInput + ' Ctrl').trim();\n                        currentChain = (currentChain + ' Ctrl').trim();\n                    }\n                    if (event.metaKey && event.key != 'Meta') {\n                        userInput = (userInput + ' Accel').trim();\n                        currentChain = (currentChain + ' Accel').trim();\n                    }\n                    if (event.altKey && event.key != 'Alt') {\n                        userInput = (userInput + ' Alt').trim();\n                        currentChain = (currentChain + ' Alt').trim();\n                    }\n                    if (event.shiftKey && event.key != 'Shift') {\n                        userInput = (userInput + ' Shift').trim();\n                        currentChain = (currentChain + ' Shift').trim();\n                    }\n                    /** if not a modefier key, add to user input and current chain */\n                    if (modKeys.lastIndexOf(event.key) === -1) {\n                        userInput = (userInput + ' ' + key).trim();\n                        currentChain = (currentChain + ' ' + key).trim();\n                        /** if a modefier key, add to user input and current chain */\n                    }\n                    else {\n                        if (event.key === 'Meta') {\n                            userInput = (userInput + ' Accel').trim();\n                            currentChain = (currentChain + ' Accel').trim();\n                        }\n                        else if (event.key === 'Control') {\n                            userInput = (userInput + ' Ctrl').trim();\n                            currentChain = (currentChain + ' Ctrl').trim();\n                        }\n                        else if (event.key === 'Shift') {\n                            userInput = (userInput + ' Shift').trim();\n                            currentChain = (currentChain + ' Shift').trim();\n                        }\n                        else if (event.key === 'Alt') {\n                            userInput = (userInput + ' Alt').trim();\n                            currentChain = (currentChain + ' Alt').trim();\n                        }\n                        else {\n                            userInput = (userInput + ' ' + event.key).trim();\n                            currentChain = (currentChain + ' ' + event.key).trim();\n                        }\n                    }\n                    /** if not a chain, add the key to user input and current chain */\n                }\n                else {\n                    /** if modefier key, rename */\n                    if (event.key === 'Control') {\n                        userInput = (userInput + ' Ctrl').trim();\n                        currentChain = (currentChain + ' Ctrl').trim();\n                    }\n                    else if (event.key === 'Meta') {\n                        userInput = (userInput + ' Accel').trim();\n                        currentChain = (currentChain + ' Accel').trim();\n                    }\n                    else if (event.key === 'Shift') {\n                        userInput = (userInput + ' Shift').trim();\n                        currentChain = (currentChain + ' Shift').trim();\n                    }\n                    else if (event.key === 'Alt') {\n                        userInput = (userInput + ' Alt').trim();\n                        currentChain = (currentChain + ' Alt').trim();\n                        /** if not a modefier key, add it regularly */\n                    }\n                    else {\n                        userInput = (userInput + ' ' + key).trim();\n                        currentChain = (currentChain + ' ' + key).trim();\n                    }\n                }\n            }\n            /** update state of keys and currentChain */\n            this.setState({\n                keys: keys,\n                currentChain: currentChain\n            });\n            return [userInput, keys, currentChain];\n        };\n        /**\n         * Check if shorcut being typed will work\n         * (does not end with ctrl, alt, command, or shift)\n         * */\n        this.checkNonFunctional = (shortcut) => {\n            const dontEnd = ['Ctrl', 'Alt', 'Accel', 'Shift'];\n            const shortcutKeys = this.state.currentChain.split(' ');\n            const last = shortcutKeys[shortcutKeys.length - 1];\n            this.setState({\n                isFunctional: !(dontEnd.indexOf(last) !== -1)\n            });\n            return dontEnd.indexOf(last) !== -1;\n        };\n        /** Check if shortcut being typed is already taken */\n        this.checkShortcutAvailability = (userInput, keys, currentChain) => {\n            /** First, check whole shortcut */\n            let isAvailable = Object.keys(this.props.keyBindingsUsed).indexOf(keys.join(' ') + currentChain + '_' + this.props.shortcut.selector) === -1 || userInput === '';\n            let takenByObject = new TakenByObject();\n            if (isAvailable) {\n                /** Next, check each piece of a chain */\n                for (let binding of keys) {\n                    if (Object.keys(this.props.keyBindingsUsed).indexOf(binding + '_' + this.props.shortcut.selector) !== -1 &&\n                        binding !== '') {\n                        isAvailable = false;\n                        takenByObject =\n                            this.props.keyBindingsUsed[binding + '_' + this.props.shortcut.selector];\n                        break;\n                    }\n                }\n                /** Check current chain */\n                if (isAvailable &&\n                    Object.keys(this.props.keyBindingsUsed).indexOf(currentChain + '_' + this.props.shortcut.selector) !== -1 &&\n                    currentChain !== '') {\n                    isAvailable = false;\n                    takenByObject =\n                        this.props.keyBindingsUsed[currentChain + '_' + this.props.shortcut.selector];\n                }\n                /** If unavailable set takenByObject */\n            }\n            else {\n                takenByObject =\n                    this.props.keyBindingsUsed[keys.join(' ') + currentChain + '_' + this.props.shortcut.selector];\n            }\n            /** allow to set shortcut to what it initially was if replacing */\n            if (!isAvailable) {\n                if (takenByObject.takenBy.id === this.props.shortcut.id &&\n                    this.props.newOrReplace === 'replace') {\n                    isAvailable = true;\n                    takenByObject = new TakenByObject();\n                }\n            }\n            this.setState({ isAvailable: isAvailable });\n            return takenByObject;\n        };\n        /** Parse and normalize user input */\n        this.handleInput = (event) => {\n            event.preventDefault();\n            this.setState({ selected: false });\n            const parsed = this.parseChaining(event, this.state.value, this.state.userInput, this.state.keys, this.state.currentChain);\n            const userInput = parsed[0];\n            const keys = parsed[1];\n            const currentChain = parsed[2];\n            const value = this.props.toSymbols(userInput);\n            let takenByObject = this.checkShortcutAvailability(userInput, keys, currentChain);\n            this.checkConflict(takenByObject, keys);\n            this.setState({\n                value: value,\n                userInput: userInput,\n                takenByObject: takenByObject,\n                keys: keys,\n                currentChain: currentChain\n            }, () => this.checkNonFunctional(this.state.userInput));\n        };\n        this.handleBlur = (event) => {\n            if (event.relatedTarget === null ||\n                (event.relatedTarget.id !== 'no-blur' &&\n                    event.relatedTarget.id !== 'overwrite')) {\n                this.props.toggleInput();\n                this.setState({\n                    value: '',\n                    userInput: ''\n                });\n                this.props.clearConflicts();\n            }\n        };\n        this.state = {\n            value: this.props.placeholder,\n            userInput: '',\n            isAvailable: true,\n            isFunctional: this.props.newOrReplace === 'replace',\n            takenByObject: new TakenByObject(),\n            keys: new Array(),\n            currentChain: '',\n            selected: true\n        };\n    }\n    checkConflict(takenByObject, keys) {\n        if (takenByObject.id !== '' &&\n            takenByObject.takenBy.id !== this.props.shortcut.id) {\n            this.props.sortConflict(this.props.shortcut, takenByObject, takenByObject.takenByLabel, '');\n        }\n        else {\n            this.props.clearConflicts();\n        }\n    }\n    render() {\n        const trans = this.props.translator.load('jupyterlab');\n        let inputClassName = 'jp-Shortcuts-Input';\n        if (!this.state.isAvailable) {\n            inputClassName += ' jp-mod-unavailable-Input';\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: this.props.displayInput\n                ? this.props.newOrReplace === 'new'\n                    ? 'jp-Shortcuts-InputBox jp-Shortcuts-InputBoxNew'\n                    : 'jp-Shortcuts-InputBox'\n                : 'jp-mod-hidden', onBlur: event => this.handleBlur(event) },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { tabIndex: 0, id: \"no-blur\", className: inputClassName, onKeyDown: this.handleInput, ref: input => input && input.focus() },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", { className: this.state.selected && this.props.newOrReplace === 'replace'\n                        ? 'jp-Shortcuts-InputText jp-mod-selected-InputText'\n                        : this.state.value === ''\n                            ? 'jp-Shortcuts-InputText jp-mod-waiting-InputText'\n                            : 'jp-Shortcuts-InputText' }, this.state.value === ''\n                    ? trans.__('press keys')\n                    : this.state.value)),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: !this.state.isFunctional\n                    ? 'jp-Shortcuts-Submit jp-mod-defunc-Submit'\n                    : !this.state.isAvailable\n                        ? 'jp-Shortcuts-Submit jp-mod-conflict-Submit'\n                        : 'jp-Shortcuts-Submit', id: 'no-blur', disabled: !this.state.isAvailable || !this.state.isFunctional, onClick: () => {\n                    if (this.props.newOrReplace === 'new') {\n                        this.handleUpdate();\n                        this.setState({\n                            value: '',\n                            keys: [],\n                            currentChain: ''\n                        });\n                        this.props.toggleInput();\n                    }\n                    else {\n                        /** don't replace if field has not been edited */\n                        if (this.state.selected) {\n                            this.props.toggleInput();\n                            this.setState({\n                                value: '',\n                                userInput: ''\n                            });\n                            this.props.clearConflicts();\n                        }\n                        else {\n                            void this.handleReplace();\n                        }\n                    }\n                } }, this.state.isAvailable ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.checkIcon.react, null) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.errorIcon.react, null)),\n            !this.state.isAvailable && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { hidden: true, id: \"overwrite\", onClick: () => {\n                    void this.handleOverwrite();\n                    this.props.clearConflicts();\n                    this.props.toggleInput();\n                } }, trans.__('Overwrite')))));\n    }\n}\n//# sourceMappingURL=ShortcutInput.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShortcutItem\": () => (/* binding */ ShortcutItem)\n/* harmony export */ });\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShortcutInput */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\nvar ShortCutLocation;\n(function (ShortCutLocation) {\n    ShortCutLocation[ShortCutLocation[\"Left\"] = 0] = \"Left\";\n    ShortCutLocation[ShortCutLocation[\"Right\"] = 1] = \"Right\";\n})(ShortCutLocation || (ShortCutLocation = {}));\n/** Describe commands that are used by shortcuts */\nfunction getCommands(trans) {\n    return {\n        shortcutEditLeft: {\n            commandId: 'shortcutui:EditLeft',\n            label: trans.__('Edit First'),\n            caption: trans.__('Edit existing shortcut')\n        },\n        shortcutEditRight: {\n            commandId: 'shortcutui:EditRight',\n            label: trans.__('Edit Second'),\n            caption: trans.__('Edit existing shortcut')\n        },\n        shortcutEdit: {\n            commandId: 'shortcutui:Edit',\n            label: trans.__('Edit'),\n            caption: trans.__('Edit existing shortcut')\n        },\n        shortcutAddNew: {\n            commandId: 'shortcutui:AddNew',\n            label: trans.__('Add'),\n            caption: trans.__('Add new shortcut')\n        },\n        shortcutAddAnother: {\n            commandId: 'shortcutui:AddAnother',\n            label: trans.__('Add'),\n            caption: trans.__('Add another shortcut')\n        },\n        shortcutReset: {\n            commandId: 'shortcutui:Reset',\n            label: trans.__('Reset'),\n            caption: trans.__('Reset shortcut back to default')\n        }\n    };\n}\n/** React component for each command shortcut item */\nclass ShortcutItem extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        /** Toggle display state of input box */\n        this.toggleInputNew = () => {\n            this.setState({\n                displayNewInput: !this.state.displayNewInput\n            });\n        };\n        this.toggleInputReplaceLeft = () => {\n            this.setState({\n                displayReplaceInputLeft: !this.state.displayReplaceInputLeft\n            });\n        };\n        this.toggleInputReplaceRight = () => {\n            this.setState({\n                displayReplaceInputRight: !this.state.displayReplaceInputRight\n            });\n        };\n        this.addCommandIfNeeded = (command, action) => {\n            const key = this.props.shortcut.commandName + '_' + this.props.shortcut.selector;\n            if (!this.props.external.hasCommand(command.commandId + key)) {\n                this.props.external.addCommand(command.commandId + key, {\n                    label: command.label,\n                    caption: command.caption,\n                    execute: action\n                });\n            }\n        };\n        this.handleRightClick = (e) => {\n            this.addCommandIfNeeded(this._commands.shortcutEdit, () => this.toggleInputReplaceLeft());\n            this.addCommandIfNeeded(this._commands.shortcutEditLeft, () => this.toggleInputReplaceLeft());\n            this.addCommandIfNeeded(this._commands.shortcutEditRight, () => this.toggleInputReplaceRight());\n            this.addCommandIfNeeded(this._commands.shortcutAddNew, () => this.toggleInputNew());\n            this.addCommandIfNeeded(this._commands.shortcutAddAnother, () => this.toggleInputNew());\n            this.addCommandIfNeeded(this._commands.shortcutReset, () => this.props.resetShortcut(this.props.shortcut));\n            const key = this.props.shortcut.commandName + '_' + this.props.shortcut.selector;\n            this.setState({\n                numShortcuts: Object.keys(this.props.shortcut.keys).filter(key => this.props.shortcut.keys[key][0] !== '').length\n            }, () => {\n                let commandList = [];\n                if (this.state.numShortcuts == 2) {\n                    commandList = commandList.concat([\n                        this._commands.shortcutEditLeft.commandId + key,\n                        this._commands.shortcutEditRight.commandId + key\n                    ]);\n                }\n                else if (this.state.numShortcuts == 1) {\n                    commandList = commandList.concat([\n                        this._commands.shortcutEdit.commandId + key,\n                        this._commands.shortcutAddAnother.commandId + key\n                    ]);\n                }\n                else {\n                    commandList = commandList.concat([\n                        this._commands.shortcutAddNew.commandId + key\n                    ]);\n                }\n                if (this.props.shortcut.source === 'Custom') {\n                    commandList = commandList.concat([\n                        this._commands.shortcutReset.commandId + key\n                    ]);\n                }\n                this.props.contextMenu(e, commandList);\n            });\n        };\n        /** Transform special key names into unicode characters */\n        this.toSymbols = (value) => {\n            return value.split(' ').reduce((result, key) => {\n                if (key === 'Ctrl') {\n                    return (result + ' ⌃').trim();\n                }\n                else if (key === 'Alt') {\n                    return (result + ' ⌥').trim();\n                }\n                else if (key === 'Shift') {\n                    return (result + ' ⇧').trim();\n                }\n                else if (key === 'Accel' && _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_MAC) {\n                    return (result + ' ⌘').trim();\n                }\n                else if (key === 'Accel') {\n                    return (result + ' ⌃').trim();\n                }\n                else {\n                    return (result + ' ' + key).trim();\n                }\n            }, '');\n        };\n        this._commands = getCommands(props.external.translator.load('jupyterlab'));\n        this.state = {\n            displayNewInput: false,\n            displayReplaceInputLeft: false,\n            displayReplaceInputRight: false,\n            numShortcuts: Object.keys(this.props.shortcut.keys).filter(key => this.props.shortcut.keys[key][0] !== '').length\n        };\n    }\n    getErrorRow() {\n        const trans = this.props.external.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Row\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ConflictContainer\" },\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ErrorMessage\" }, trans.__('Shortcut already in use by %1. Overwrite it?', this.props.shortcut.takenBy.takenByLabel)),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ErrorButton\" },\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", null, trans.__('Cancel')),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", { id: \"no-blur\", onClick: () => {\n                            var _a;\n                            (_a = document.getElementById('overwrite')) === null || _a === void 0 ? void 0 : _a.click();\n                        } }, trans.__('Overwrite'))))));\n    }\n    getCategoryCell() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" }, this.props.shortcut.category));\n    }\n    getLabelCell() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-label\" }, this.props.shortcut.label)));\n    }\n    getResetShortCutLink() {\n        const trans = this.props.external.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-Reset\", onClick: () => this.props.resetShortcut(this.props.shortcut) }, trans.__('Reset')));\n    }\n    getSourceCell() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-SourceCell\" }, this.props.shortcut.source),\n            this.props.shortcut.source === 'Custom' && this.getResetShortCutLink()));\n    }\n    getOptionalSelectorCell() {\n        return this.props.showSelectors ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-selector\" }, this.props.shortcut.selector))) : null;\n    }\n    getClassNameForShortCuts(nonEmptyKeys) {\n        const classes = ['jp-Shortcuts-ShortcutCell'];\n        switch (nonEmptyKeys.length) {\n            case 1:\n                classes.push('jp-Shortcuts-SingleCell');\n                break;\n            case 0:\n                classes.push('jp-Shortcuts-EmptyCell');\n                break;\n        }\n        return classes.join(' ');\n    }\n    getToggleInputReplaceMethod(location) {\n        switch (location) {\n            case ShortCutLocation.Left:\n                return this.toggleInputReplaceLeft;\n            case ShortCutLocation.Right:\n                return this.toggleInputReplaceRight;\n        }\n    }\n    getDisplayReplaceInput(location) {\n        switch (location) {\n            case ShortCutLocation.Left:\n                return this.state.displayReplaceInputLeft;\n            case ShortCutLocation.Right:\n                return this.state.displayReplaceInputRight;\n        }\n    }\n    getOrDiplayIfNeeded(nonEmptyKeys) {\n        const trans = this.props.external.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: nonEmptyKeys.length == 2 || this.state.displayNewInput\n                ? 'jp-Shortcuts-OrTwo'\n                : 'jp-Shortcuts-Or', id: nonEmptyKeys.length == 2\n                ? 'secondor'\n                : this.state.displayReplaceInputLeft\n                    ? 'noor'\n                    : 'or' }, trans.__('or')));\n    }\n    getShortCutAsInput(key, location) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ShortcutInput, { handleUpdate: this.props.handleUpdate, deleteShortcut: this.props.deleteShortcut, toggleInput: this.getToggleInputReplaceMethod(location), shortcut: this.props.shortcut, shortcutId: key, toSymbols: this.toSymbols, keyBindingsUsed: this.props.keyBindingsUsed, sortConflict: this.props.sortConflict, clearConflicts: this.props.clearConflicts, displayInput: this.getDisplayReplaceInput(location), newOrReplace: 'replace', placeholder: this.toSymbols(this.props.shortcut.keys[key].join(', ')), translator: this.props.external.translator }));\n    }\n    getShortCutForDisplayOnly(key) {\n        return this.props.shortcut.keys[key].map((keyBinding, index) => (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutKeysContainer\", key: index },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutKeys\" }, this.toSymbols(keyBinding)),\n            index + 1 < this.props.shortcut.keys[key].length ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Comma\" }, \",\")) : null)));\n    }\n    isLocationBeingEdited(location) {\n        return ((location === ShortCutLocation.Left &&\n            this.state.displayReplaceInputLeft) ||\n            (location === ShortCutLocation.Right &&\n                this.state.displayReplaceInputRight));\n    }\n    getLocationFromIndex(index) {\n        return index === 0 ? ShortCutLocation.Left : ShortCutLocation.Right;\n    }\n    getDivForKey(index, key, nonEmptyKeys) {\n        const location = this.getLocationFromIndex(index);\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutContainer\", key: this.props.shortcut.id + '_' + index, onClick: this.getToggleInputReplaceMethod(location) },\n            this.isLocationBeingEdited(location)\n                ? this.getShortCutAsInput(key, location)\n                : this.getShortCutForDisplayOnly(key),\n            location === ShortCutLocation.Left &&\n                this.getOrDiplayIfNeeded(nonEmptyKeys)));\n    }\n    getAddLink() {\n        const trans = this.props.external.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: !this.state.displayNewInput ? 'jp-Shortcuts-Plus' : '', onClick: () => {\n                this.toggleInputNew(), this.props.clearConflicts();\n            }, id: \"add-link\" }, trans.__('Add')));\n    }\n    getInputBoxWhenToggled() {\n        return this.state.displayNewInput ? (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ShortcutInput, { handleUpdate: this.props.handleUpdate, deleteShortcut: this.props.deleteShortcut, toggleInput: this.toggleInputNew, shortcut: this.props.shortcut, shortcutId: \"\", toSymbols: this.toSymbols, keyBindingsUsed: this.props.keyBindingsUsed, sortConflict: this.props.sortConflict, clearConflicts: this.props.clearConflicts, displayInput: this.state.displayNewInput, newOrReplace: 'new', placeholder: '', translator: this.props.external.translator })) : (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null));\n    }\n    getShortCutsCell(nonEmptyKeys) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: this.getClassNameForShortCuts(nonEmptyKeys) },\n                nonEmptyKeys.map((key, index) => this.getDivForKey(index, key, nonEmptyKeys)),\n                nonEmptyKeys.length === 1 &&\n                    !this.state.displayNewInput &&\n                    !this.state.displayReplaceInputLeft &&\n                    this.getAddLink(),\n                nonEmptyKeys.length === 0 &&\n                    !this.state.displayNewInput &&\n                    this.getAddLink(),\n                this.getInputBoxWhenToggled())));\n    }\n    render() {\n        const nonEmptyKeys = Object.keys(this.props.shortcut.keys).filter((key) => this.props.shortcut.keys[key][0] !== '');\n        if (this.props.shortcut.id === 'error_row') {\n            return this.getErrorRow();\n        }\n        else {\n            return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Row\", onContextMenu: e => {\n                    e.persist();\n                    this.handleRightClick(e);\n                } },\n                this.getCategoryCell(),\n                this.getLabelCell(),\n                this.getShortCutsCell(nonEmptyKeys),\n                this.getSourceCell(),\n                this.getOptionalSelectorCell()));\n        }\n    }\n}\n//# sourceMappingURL=ShortcutItem.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShortcutList\": () => (/* binding */ ShortcutList)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ShortcutItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShortcutItem */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutItem.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nconst TOPNAV_HEIGHT = 115;\n/** React component for list of shortcuts */\nclass ShortcutList extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutListContainer\", style: {\n                height: `${this.props.height - TOPNAV_HEIGHT}px`\n            }, id: \"shortcutListContainer\" },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutList\" }, this.props.shortcuts.map((shortcut) => {\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ShortcutItem__WEBPACK_IMPORTED_MODULE_1__.ShortcutItem, { key: shortcut.commandName + '_' + shortcut.selector, resetShortcut: this.props.resetShortcut, shortcut: shortcut, handleUpdate: this.props.handleUpdate, deleteShortcut: this.props.deleteShortcut, showSelectors: this.props.showSelectors, keyBindingsUsed: this.props.keyBindingsUsed, sortConflict: this.props.sortConflict, clearConflicts: this.props.clearConflicts, contextMenu: this.props.contextMenu, external: this.props.external }));\n            }))));\n    }\n}\n//# sourceMappingURL=ShortcutList.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShortcutTitleItem\": () => (/* binding */ ShortcutTitleItem)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nclass ShortcutTitleItem extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: this.props.title.toLowerCase() === this.props.active\n                ? 'jp-Shortcuts-Header jp-Shortcuts-CurrentHeader'\n                : 'jp-Shortcuts-Header', onClick: () => this.props.updateSort(this.props.title.toLowerCase()) },\n            this.props.title,\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.caretDownEmptyThinIcon.react, { className: 'jp-Shortcuts-SortButton jp-ShortcutTitleItem-sortButton' })));\n    }\n}\n//# sourceMappingURL=ShortcutTitleItem.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShortcutUI\": () => (/* binding */ ShortcutUI)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ShortcutList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShortcutList */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutList.js\");\n/* harmony import */ var _TopNav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TopNav */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShortcutInput */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutInput.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\n\n\n/** Normalize the query text for a fuzzy search. */\nfunction normalizeQuery(text) {\n    return text.replace(/\\s+/g, '').toLowerCase();\n}\n/** Perform a fuzzy search on a single command item. */\nfunction fuzzySearch(item, query) {\n    // Create the source text to be searched.\n    const category = item.category.toLowerCase();\n    const label = item['label'].toLowerCase();\n    const source = `${category} ${label}`;\n    // Set up the match score and indices array.\n    let score = Infinity;\n    let indices = null;\n    // The regex for search word boundaries\n    const rgx = /\\b\\w/g;\n    // Search the source by word boundary.\n    // eslint-disable-next-line\n    while (true) {\n        // Find the next word boundary in the source.\n        const rgxMatch = rgx.exec(source);\n        // Break if there is no more source context.\n        if (!rgxMatch) {\n            break;\n        }\n        // Run the string match on the relevant substring.\n        const match = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.StringExt.matchSumOfDeltas(source, query, rgxMatch.index);\n        // Break if there is no match.\n        if (!match) {\n            break;\n        }\n        // Update the match if the score is better.\n        if (match && match.score <= score) {\n            score = match.score;\n            indices = match.indices;\n        }\n    }\n    // Bail if there was no match.\n    if (!indices || score === Infinity) {\n        return null;\n    }\n    // Compute the pivot index between category and label text.\n    const pivot = category.length + 1;\n    // Find the slice index to separate matched indices.\n    const j = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.lowerBound(indices, pivot, (a, b) => a - b);\n    // Extract the matched category and label indices.\n    const categoryIndices = indices.slice(0, j);\n    const labelIndices = indices.slice(j);\n    // Adjust the label indices for the pivot offset.\n    for (let i = 0, n = labelIndices.length; i < n; ++i) {\n        labelIndices[i] -= pivot;\n    }\n    // Handle a pure label match.\n    if (categoryIndices.length === 0) {\n        return {\n            matchType: 0 /* MatchType.Label */,\n            categoryIndices: null,\n            labelIndices,\n            score,\n            item\n        };\n    }\n    // Handle a pure category match.\n    if (labelIndices.length === 0) {\n        return {\n            matchType: 1 /* MatchType.Category */,\n            categoryIndices,\n            labelIndices: null,\n            score,\n            item\n        };\n    }\n    // Handle a split match.\n    return {\n        matchType: 2 /* MatchType.Split */,\n        categoryIndices,\n        labelIndices,\n        score,\n        item\n    };\n}\n/** Perform a fuzzy match on an array of command items. */\nfunction matchItems(items, query) {\n    // Normalize the query text to lower case with no whitespace.\n    query = normalizeQuery(query);\n    // Create the array to hold the scores.\n    let scores = [];\n    // Iterate over the items and match against the query.\n    let itemList = Object.keys(items);\n    for (let i = 0, n = itemList.length; i < n; ++i) {\n        let item = items[itemList[i]];\n        // If the query is empty, all items are matched by default.\n        if (!query) {\n            scores.push({\n                matchType: 3 /* MatchType.Default */,\n                categoryIndices: null,\n                labelIndices: null,\n                score: 0,\n                item\n            });\n            continue;\n        }\n        // Run the fuzzy search for the item and query.\n        let score = fuzzySearch(item, query);\n        // Ignore the item if it is not a match.\n        if (!score) {\n            continue;\n        }\n        // Add the score to the results.\n        scores.push(score);\n    }\n    // Return the final array of scores.\n    return scores;\n}\n/** Transform SettingRegistry's shortcut list to list of ShortcutObjects */\nfunction getShortcutObjects(external, settings) {\n    const shortcuts = settings.composite.shortcuts;\n    let shortcutObjects = {};\n    shortcuts.forEach((shortcut) => {\n        let key = shortcut.command + '_' + shortcut.selector;\n        if (Object.keys(shortcutObjects).indexOf(key) !== -1) {\n            let currentCount = shortcutObjects[key].numberOfShortcuts;\n            shortcutObjects[key].keys[currentCount] = shortcut.keys;\n            shortcutObjects[key].numberOfShortcuts++;\n        }\n        else {\n            let shortcutObject = new _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ShortcutObject();\n            shortcutObject.commandName = shortcut.command;\n            let label = external.getLabel(shortcut.command);\n            if (!label) {\n                label = shortcut.command.split(':')[1];\n            }\n            shortcutObject.label = label;\n            shortcutObject.category = shortcut.command.split(':')[0];\n            shortcutObject.keys[0] = shortcut.keys;\n            shortcutObject.selector = shortcut.selector;\n            // TODO needs translation\n            shortcutObject.source = 'Default';\n            shortcutObject.id = key;\n            shortcutObject.numberOfShortcuts = 1;\n            shortcutObjects[key] = shortcutObject;\n        }\n    });\n    // find all the shortcuts that have custom settings\n    const userShortcuts = settings.user.shortcuts;\n    userShortcuts.forEach((userSetting) => {\n        const command = userSetting.command;\n        const selector = userSetting.selector;\n        const keyTo = command + '_' + selector;\n        if (shortcutObjects[keyTo]) {\n            // TODO needs translation\n            shortcutObjects[keyTo].source = 'Custom';\n        }\n    });\n    return shortcutObjects;\n}\n/** Get list of all shortcut keybindings currently in use\n * An object where keys are unique keyBinding_selector and values are shortcut objects **/\nfunction getKeyBindingsUsed(shortcutObjects) {\n    let keyBindingsUsed = {};\n    Object.keys(shortcutObjects).forEach((shortcut) => {\n        Object.keys(shortcutObjects[shortcut].keys).forEach((key) => {\n            const takenBy = new _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.TakenByObject(shortcutObjects[shortcut]);\n            takenBy.takenByKey = key;\n            keyBindingsUsed[shortcutObjects[shortcut].keys[key].join(' ') +\n                '_' +\n                shortcutObjects[shortcut].selector] = takenBy;\n        });\n    });\n    return keyBindingsUsed;\n}\n/** Top level React component for widget */\nclass ShortcutUI extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        /** Set the current seach query */\n        this.updateSearchQuery = (event) => {\n            this.setState({\n                searchQuery: event.target['value']\n            }, () => this.setState({\n                filteredShortcutList: this.searchFilterShortcuts(this.state.shortcutList)\n            }, () => {\n                this.sortShortcuts();\n            }));\n        };\n        /** Reset all shortcuts to their defaults */\n        this.resetShortcuts = async () => {\n            const settings = await this.props.external.getAllShortCutSettings();\n            for (const key of Object.keys(settings.user)) {\n                await this.props.external.removeShortCut(key);\n            }\n            await this._refreshShortcutList();\n        };\n        /** Set new shortcut for command, refresh state */\n        this.handleUpdate = async (shortcutObject, keys) => {\n            const settings = await this.props.external.getAllShortCutSettings();\n            const userShortcuts = settings.user.shortcuts;\n            const newUserShortcuts = [];\n            let found = false;\n            for (let shortcut of userShortcuts) {\n                if (shortcut['command'] === shortcutObject.commandName &&\n                    shortcut['selector'] === shortcutObject.selector) {\n                    newUserShortcuts.push({\n                        command: shortcut['command'],\n                        selector: shortcut['selector'],\n                        keys: keys\n                    });\n                    found = true;\n                }\n                else {\n                    newUserShortcuts.push(shortcut);\n                }\n            }\n            if (!found) {\n                newUserShortcuts.push({\n                    command: shortcutObject.commandName,\n                    selector: shortcutObject.selector,\n                    keys: keys\n                });\n            }\n            await settings.set('shortcuts', newUserShortcuts);\n            await this._refreshShortcutList();\n        };\n        /** Delete shortcut for command, refresh state */\n        this.deleteShortcut = async (shortcutObject, shortcutId) => {\n            await this.handleUpdate(shortcutObject, ['']);\n            await this._refreshShortcutList();\n        };\n        /** Reset a specific shortcut to its default settings */\n        this.resetShortcut = async (shortcutObject) => {\n            const settings = await this.props.external.getAllShortCutSettings();\n            const userShortcuts = settings.user.shortcuts;\n            const newUserShortcuts = [];\n            for (let shortcut of userShortcuts) {\n                if (shortcut['command'] !== shortcutObject.commandName ||\n                    shortcut['selector'] !== shortcutObject.selector) {\n                    newUserShortcuts.push(shortcut);\n                }\n            }\n            await settings.set('shortcuts', newUserShortcuts);\n            await this._refreshShortcutList();\n        };\n        /** Toggles showing command selectors */\n        this.toggleSelectors = () => {\n            this.setState({ showSelectors: !this.state.showSelectors });\n        };\n        /** Set the current list sort order */\n        this.updateSort = (value) => {\n            if (value !== this.state.currentSort) {\n                this.setState({ currentSort: value }, this.sortShortcuts);\n            }\n        };\n        /** Sort shortcut list so that an error row is right below the one currently being set */\n        this.sortConflict = (newShortcut, takenBy) => {\n            const shortcutList = this.state.filteredShortcutList;\n            if (shortcutList.filter(shortcut => shortcut.id === 'error_row').length === 0) {\n                const errorRow = new _ShortcutInput__WEBPACK_IMPORTED_MODULE_2__.ErrorObject();\n                errorRow.takenBy = takenBy;\n                errorRow.id = 'error_row';\n                shortcutList.splice(shortcutList.indexOf(newShortcut) + 1, 0, errorRow);\n                errorRow.hasConflict = true;\n                this.setState({ filteredShortcutList: shortcutList });\n            }\n        };\n        /** Remove conflict flag from all shortcuts */\n        this.clearConflicts = () => {\n            /** Remove error row */\n            const shortcutList = this.state.filteredShortcutList.filter(shortcut => shortcut.id !== 'error_row');\n            shortcutList.forEach((shortcut) => {\n                shortcut.hasConflict = false;\n            });\n            this.setState({ filteredShortcutList: shortcutList });\n        };\n        this.contextMenu = (event, commandIDs) => {\n            event.persist();\n            this.setState({\n                contextMenu: this.props.external.createMenu()\n            }, () => {\n                event.preventDefault();\n                for (let command of commandIDs) {\n                    this.state.contextMenu.addItem({ command });\n                }\n                this.state.contextMenu.open(event.clientX, event.clientY);\n            });\n        };\n        this.state = {\n            shortcutList: {},\n            filteredShortcutList: new Array(),\n            shortcutsFetched: false,\n            searchQuery: '',\n            showSelectors: false,\n            currentSort: 'category',\n            keyBindingsUsed: {},\n            contextMenu: this.props.external.createMenu()\n        };\n    }\n    /** Fetch shortcut list on mount */\n    componentDidMount() {\n        void this._refreshShortcutList();\n    }\n    /** Fetch shortcut list from SettingRegistry  */\n    async _refreshShortcutList() {\n        const shortcuts = await this.props.external.getAllShortCutSettings();\n        const shortcutObjects = getShortcutObjects(this.props.external, shortcuts);\n        this.setState({\n            shortcutList: shortcutObjects,\n            filteredShortcutList: this.searchFilterShortcuts(shortcutObjects),\n            shortcutsFetched: true\n        }, () => {\n            let keyBindingsUsed = getKeyBindingsUsed(shortcutObjects);\n            this.setState({ keyBindingsUsed });\n            this.sortShortcuts();\n        });\n    }\n    /** Filter shortcut list using current search query */\n    searchFilterShortcuts(shortcutObjects) {\n        const filteredShortcuts = matchItems(shortcutObjects, this.state.searchQuery).map((item) => {\n            return item.item;\n        });\n        return filteredShortcuts;\n    }\n    /** Sort shortcut list using current sort property  */\n    sortShortcuts() {\n        const shortcuts = this.state.filteredShortcutList;\n        let filterCritera = this.state.currentSort;\n        if (filterCritera === 'command') {\n            filterCritera = 'label';\n        }\n        if (filterCritera !== '') {\n            shortcuts.sort((a, b) => {\n                const compareA = a.get(filterCritera);\n                const compareB = b.get(filterCritera);\n                if (compareA < compareB) {\n                    return -1;\n                }\n                else if (compareA > compareB) {\n                    return 1;\n                }\n                else {\n                    return a['label'] < b['label'] ? -1 : a['label'] > b['label'] ? 1 : 0;\n                }\n            });\n        }\n        this.setState({ filteredShortcutList: shortcuts });\n    }\n    render() {\n        if (!this.state.shortcutsFetched) {\n            return null;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-ShortcutUI\", id: \"jp-shortcutui\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_TopNav__WEBPACK_IMPORTED_MODULE_3__.TopNav, { updateSearchQuery: this.updateSearchQuery, resetShortcuts: this.resetShortcuts, toggleSelectors: this.toggleSelectors, showSelectors: this.state.showSelectors, updateSort: this.updateSort, currentSort: this.state.currentSort, width: this.props.width, external: this.props.external }),\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutList__WEBPACK_IMPORTED_MODULE_4__.ShortcutList, { shortcuts: this.state.filteredShortcutList, resetShortcut: this.resetShortcut, handleUpdate: this.handleUpdate, deleteShortcut: this.deleteShortcut, showSelectors: this.state.showSelectors, keyBindingsUsed: this.state.keyBindingsUsed, sortConflict: this.sortConflict, clearConflicts: this.clearConflicts, height: this.props.height, contextMenu: this.contextMenu, external: this.props.external })));\n    }\n}\n//# sourceMappingURL=ShortcutUI.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CommandIDs\": () => (/* binding */ CommandIDs),\n/* harmony export */   \"TopNav\": () => (/* binding */ TopNav)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ShortcutTitleItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShortcutTitleItem */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutTitleItem.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\n\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.showSelectors = 'shortcutui:showSelectors';\n    CommandIDs.resetAll = 'shortcutui:resetAll';\n})(CommandIDs || (CommandIDs = {}));\nfunction Symbols(props) {\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Symbols\" },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"table\", null,\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tbody\", null,\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tr\", null,\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Cmd\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2318\"),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Ctrl\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2303\")),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"tr\", null,\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Alt\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u2325\"),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"kbd\", null, \"Shift\")),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"td\", null, \"\\u21E7\"))))));\n}\nfunction AdvancedOptions(props) {\n    const trans = props.translator.load('jupyterlab');\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-AdvancedOptions\" },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-AdvancedOptionsLink\", onClick: () => props.toggleSelectors() }, props.showSelectors\n            ? trans.__('Hide Selectors')\n            : trans.__('Show Selectors')),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", { className: \"jp-Shortcuts-AdvancedOptionsLink\", onClick: () => props.resetShortcuts() }, trans.__('Reset All'))));\n}\n/** React component for top navigation */\nclass TopNav extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        this.addMenuCommands();\n        this.menu = this.props.external.createMenu();\n        this.menu.addItem({ command: CommandIDs.showSelectors });\n        this.menu.addItem({ command: CommandIDs.resetAll });\n    }\n    addMenuCommands() {\n        const trans = this.props.external.translator.load('jupyterlab');\n        if (!this.props.external.hasCommand(CommandIDs.showSelectors)) {\n            this.props.external.addCommand(CommandIDs.showSelectors, {\n                label: trans.__('Toggle Selectors'),\n                caption: trans.__('Toggle command selectors'),\n                execute: () => {\n                    this.props.toggleSelectors();\n                }\n            });\n        }\n        if (!this.props.external.hasCommand(CommandIDs.resetAll)) {\n            this.props.external.addCommand(CommandIDs.resetAll, {\n                label: trans.__('Reset All'),\n                caption: trans.__('Reset all shortcuts'),\n                execute: () => {\n                    this.props.resetShortcuts();\n                }\n            });\n        }\n    }\n    getShortCutTitleItem(title) {\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ShortcutTitleItem__WEBPACK_IMPORTED_MODULE_2__.ShortcutTitleItem, { title: title, updateSort: this.props.updateSort, active: this.props.currentSort })));\n    }\n    render() {\n        const trans = this.props.external.translator.load('jupyterlab');\n        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Top\" },\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-TopNav\" },\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(Symbols, null),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.InputGroup, { className: \"jp-Shortcuts-Search\", type: \"text\", onChange: event => this.props.updateSearchQuery(event), placeholder: trans.__('Search…'), rightIcon: \"ui-components:search\" }),\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(AdvancedOptions, { toggleSelectors: this.props.toggleSelectors, showSelectors: this.props.showSelectors, resetShortcuts: this.props.resetShortcuts, menu: this.menu, translator: this.props.external.translator })),\n            react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-HeaderRowContainer\" },\n                react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-HeaderRow\" },\n                    this.getShortCutTitleItem(trans.__('Category')),\n                    this.getShortCutTitleItem(trans.__('Command')),\n                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"jp-Shortcuts-Cell\" },\n                        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"title-div\" }, trans.__('Shortcut'))),\n                    this.getShortCutTitleItem(trans.__('Source')),\n                    this.props.showSelectors &&\n                        this.getShortCutTitleItem(trans.__('Selectors'))))));\n    }\n}\n//# sourceMappingURL=TopNav.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/components/TopNav.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/commands */ \"webpack/sharing/consume/default/@lumino/commands/@lumino/commands\");\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_commands__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/disposable */ \"webpack/sharing/consume/default/@lumino/disposable/@lumino/disposable\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lumino/domutils */ \"webpack/sharing/consume/default/@lumino/domutils/@lumino/domutils\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lumino_domutils__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module shortcuts-extension\n */\n\n\n\n\n\n\n\n\n\nfunction getExternalForJupyterLab(settingRegistry, app, translator) {\n    const { commands } = app;\n    const shortcutPluginLocation = '@jupyterlab/shortcuts-extension:shortcuts';\n    return {\n        translator,\n        getAllShortCutSettings: () => settingRegistry.load(shortcutPluginLocation, true),\n        removeShortCut: (key) => settingRegistry.remove(shortcutPluginLocation, key),\n        createMenu: () => new _lumino_widgets__WEBPACK_IMPORTED_MODULE_7__.Menu({ commands }),\n        hasCommand: (id) => commands.hasCommand(id),\n        addCommand: (id, options) => commands.addCommand(id, options),\n        getLabel: (id) => commands.label(id)\n    };\n}\n/**\n * The default shortcuts extension.\n *\n * #### Notes\n * Shortcut values are stored in the setting system. The default values for each\n * shortcut are preset in the settings schema file of this extension.\n * Additionally, each shortcut can be individually set by the end user by\n * modifying its setting (either in the text editor or by modifying its\n * underlying JSON schema file).\n *\n * When setting shortcut selectors, there are two concepts to consider:\n * specificity and matchability. These two interact in sometimes\n * counterintuitive ways. Keyboard events are triggered from an element and\n * they propagate up the DOM until they reach the `documentElement` (`<body>`).\n *\n * When a registered shortcut sequence is fired, the shortcut manager checks\n * the node that fired the event and each of its ancestors until a node matches\n * one or more registered selectors. The *first* matching selector in the\n * chain of ancestors will invoke the shortcut handler and the traversal will\n * end at that point. If a node matches more than one selector, the handler for\n * whichever selector is more *specific* fires.\n * @see https://www.w3.org/TR/css3-selectors/#specificity\n *\n * The practical consequence of this is that a very broadly matching selector,\n * e.g. `'*'` or `'div'` may match and therefore invoke a handler *before* a\n * more specific selector. The most common pitfall is to use the universal\n * (`'*'`) selector. For almost any use case where a global keyboard shortcut is\n * required, using the `'body'` selector is more appropriate.\n */\nconst shortcuts = {\n    id: '@jupyterlab/shortcuts-extension:shortcuts',\n    description: 'Adds the keyboard shortcuts editor.',\n    requires: [_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__.ISettingRegistry],\n    optional: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.ITranslator, _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.IFormRendererRegistry],\n    activate: async (app, registry, translator, editorRegistry) => {\n        const translator_ = translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;\n        const trans = translator_.load('jupyterlab');\n        const { commands } = app;\n        let canonical;\n        let loaded = {};\n        if (editorRegistry) {\n            const component = {\n                fieldRenderer: (props) => {\n                    return (0,_renderer__WEBPACK_IMPORTED_MODULE_8__.renderShortCut)({\n                        external: getExternalForJupyterLab(registry, app, translator_),\n                        ...props\n                    });\n                }\n            };\n            editorRegistry.addRenderer(`${shortcuts.id}.shortcuts`, component);\n        }\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        function populate(schema) {\n            const commands = app.commands.listCommands().join('\\n');\n            loaded = {};\n            schema.properties.shortcuts.default = Object.keys(registry.plugins)\n                .map(plugin => {\n                const shortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                loaded[plugin] = shortcuts;\n                return shortcuts;\n            })\n                .concat([schema.properties.shortcuts.default])\n                .reduce((acc, val) => {\n                if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_6__.Platform.IS_MAC) {\n                    return acc.concat(val);\n                }\n                else {\n                    // If platform is not MacOS, remove all shortcuts containing Cmd\n                    // as they will be modified; e.g. `Cmd A` becomes `A`\n                    return acc.concat(val.filter(shortcut => !shortcut.keys.some(key => {\n                        const { cmd } = _lumino_commands__WEBPACK_IMPORTED_MODULE_3__.CommandRegistry.parseKeystroke(key);\n                        return cmd;\n                    })));\n                }\n            }, []) // flatten one level\n                .sort((a, b) => a.command.localeCompare(b.command));\n            schema.properties.shortcuts.description = trans.__(`Note: To disable a system default shortcut,\ncopy it to User Preferences and add the\n\"disabled\" key, for example:\n{\n    \"command\": \"application:activate-next-tab\",\n    \"keys\": [\n        \"Ctrl Shift ]\"\n    ],\n    \"selector\": \"body\",\n    \"disabled\": true\n}\n\nList of commands followed by keyboard shortcuts:\n%1\n\nList of keyboard shortcuts:`, commands);\n        }\n        registry.pluginChanged.connect(async (sender, plugin) => {\n            if (plugin !== shortcuts.id) {\n                // If the plugin changed its shortcuts, reload everything.\n                const oldShortcuts = loaded[plugin];\n                const newShortcuts = registry.plugins[plugin].schema['jupyter.lab.shortcuts'] || [];\n                if (oldShortcuts === undefined ||\n                    !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepEqual(oldShortcuts, newShortcuts)) {\n                    // Empty the default values to avoid shortcut collisions.\n                    canonical = null;\n                    const schema = registry.plugins[shortcuts.id].schema;\n                    schema.properties.shortcuts.default = [];\n                    // Reload the settings.\n                    await registry.load(shortcuts.id, true);\n                }\n            }\n        });\n        // Transform the plugin object to return different schema than the default.\n        registry.transform(shortcuts.id, {\n            compose: plugin => {\n                var _a, _b, _c, _d;\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                const defaults = (_c = (_b = (_a = canonical.properties) === null || _a === void 0 ? void 0 : _a.shortcuts) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : [];\n                const user = {\n                    shortcuts: (_d = plugin.data.user.shortcuts) !== null && _d !== void 0 ? _d : []\n                };\n                const composite = {\n                    shortcuts: _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_0__.SettingRegistry.reconcileShortcuts(defaults, user.shortcuts)\n                };\n                plugin.data = { composite, user };\n                return plugin;\n            },\n            fetch: plugin => {\n                // Only override the canonical schema the first time.\n                if (!canonical) {\n                    canonical = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_4__.JSONExt.deepCopy(plugin.schema);\n                    populate(canonical);\n                }\n                return {\n                    data: plugin.data,\n                    id: plugin.id,\n                    raw: plugin.raw,\n                    schema: canonical,\n                    version: plugin.version\n                };\n            }\n        });\n        try {\n            // Repopulate the canonical variable after the setting registry has\n            // preloaded all initial plugins.\n            canonical = null;\n            const settings = await registry.load(shortcuts.id);\n            Private.loadShortcuts(commands, settings.composite);\n            settings.changed.connect(() => {\n                Private.loadShortcuts(commands, settings.composite);\n            });\n        }\n        catch (error) {\n            console.error(`Loading ${shortcuts.id} failed.`, error);\n        }\n    },\n    autoStart: true\n};\n/**\n * Export the shortcut plugin as default.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shortcuts);\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The internal collection of currently loaded shortcuts.\n     */\n    let disposables;\n    /**\n     * Load the keyboard shortcuts from settings.\n     */\n    function loadShortcuts(commands, composite) {\n        var _a;\n        const shortcuts = ((_a = composite === null || composite === void 0 ? void 0 : composite.shortcuts) !== null && _a !== void 0 ? _a : []);\n        if (disposables) {\n            disposables.dispose();\n        }\n        disposables = shortcuts.reduce((acc, val) => {\n            const options = normalizeOptions(val);\n            if (options) {\n                acc.add(commands.addKeyBinding(options));\n            }\n            return acc;\n        }, new _lumino_disposable__WEBPACK_IMPORTED_MODULE_5__.DisposableSet());\n    }\n    Private.loadShortcuts = loadShortcuts;\n    /**\n     * Normalize potential keyboard shortcut options.\n     */\n    function normalizeOptions(value) {\n        if (!value || typeof value !== 'object') {\n            return undefined;\n        }\n        const { isArray } = Array;\n        const valid = 'command' in value &&\n            'keys' in value &&\n            'selector' in value &&\n            isArray(value.keys);\n        return valid ? value : undefined;\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderShortCut\": () => (/* binding */ renderShortCut)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components */ \"../node_modules/@jupyterlab/shortcuts-extension/lib/components/ShortcutUI.js\");\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n\nconst renderShortCut = (props) => {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_components__WEBPACK_IMPORTED_MODULE_1__.ShortcutUI, { external: props.external, height: 1000, width: 1000 });\n};\n//# sourceMappingURL=renderer.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shortcuts-extension/lib/renderer.js?");

/***/ })

}]);