"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_cell-toolbar_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CellBarExtension\": () => (/* binding */ CellBarExtension),\n/* harmony export */   \"CellToolbarTracker\": () => (/* binding */ CellToolbarTracker)\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/observables */ \"webpack/sharing/consume/default/@jupyterlab/observables/@jupyterlab/observables\");\n/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ \"webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components\");\n/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/signaling */ \"webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_4__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n\n/*\n * Text mime types\n */\nconst TEXT_MIME_TYPES = [\n    'text/plain',\n    'application/vnd.jupyter.stdout',\n    'application/vnd.jupyter.stderr'\n];\n/**\n * Widget cell toolbar classes\n */\nconst CELL_TOOLBAR_CLASS = 'jp-cell-toolbar';\nconst CELL_MENU_CLASS = 'jp-cell-menu';\n/**\n * Class for a cell whose contents overlap with the cell toolbar\n */\nconst TOOLBAR_OVERLAP_CLASS = 'jp-toolbar-overlap';\n/**\n * Watch a notebook so that a cell toolbar appears on the active cell\n */\nclass CellToolbarTracker {\n    constructor(panel, toolbar) {\n        var _a;\n        this._isDisposed = false;\n        this._panel = panel;\n        this._previousActiveCell = this._panel.content.activeCell;\n        this._toolbar = toolbar;\n        this._onToolbarChanged();\n        this._toolbar.changed.connect(this._onToolbarChanged, this);\n        // Only add the toolbar to the notebook's active cell (if any) once it has fully rendered and been revealed.\n        void panel.revealed.then(() => {\n            // Wait one frame (at 60 fps) for the panel to render the first cell, then display the cell toolbar on it if possible.\n            setTimeout(() => {\n                this._onActiveCellChanged(panel.content);\n            }, 1000 / 60);\n        });\n        // Check whether the toolbar should be rendered upon a layout change\n        panel.content.renderingLayoutChanged.connect(this._onActiveCellChanged, this);\n        // Handle subsequent changes of active cell.\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.metadataChanged.connect(this._onMetadataChanged, this);\n        panel.disposed.connect(() => {\n            var _a;\n            panel.content.activeCellChanged.disconnect(this._onActiveCellChanged);\n            (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.metadataChanged.disconnect(this._onMetadataChanged);\n        });\n    }\n    _onMetadataChanged(model, args) {\n        if (args.key === 'jupyter') {\n            if (typeof args.newValue === 'object' &&\n                args.newValue.source_hidden === true &&\n                (args.type === 'add' || args.type === 'change')) {\n                // Cell just became hidden; remove toolbar\n                this._removeToolbar(model);\n            }\n            // Check whether input visibility changed\n            else if (typeof args.oldValue === 'object' &&\n                args.oldValue.source_hidden === true) {\n                // Cell just became visible; add toolbar\n                this._addToolbar(model);\n            }\n        }\n    }\n    _onActiveCellChanged(notebook) {\n        if (this._previousActiveCell && !this._previousActiveCell.isDisposed) {\n            // Disposed cells do not have a model anymore.\n            this._removeToolbar(this._previousActiveCell.model);\n            this._previousActiveCell.model.metadataChanged.disconnect(this._onMetadataChanged);\n        }\n        const activeCell = notebook.activeCell;\n        if (activeCell === null || activeCell.inputHidden) {\n            return;\n        }\n        activeCell.model.metadataChanged.connect(this._onMetadataChanged, this);\n        this._addToolbar(activeCell.model);\n        this._previousActiveCell = activeCell;\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._toolbar.changed.disconnect(this._onToolbarChanged, this);\n        const cells = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.context.model.cells;\n        if (cells) {\n            for (const model of cells) {\n                this._removeToolbar(model);\n            }\n        }\n        this._panel = null;\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal.clearData(this);\n    }\n    _addToolbar(model) {\n        const cell = this._getCell(model);\n        if (cell) {\n            const toolbarWidget = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.Toolbar();\n            toolbarWidget.addClass(CELL_MENU_CLASS);\n            const promises = [];\n            for (const { name, widget } of this._toolbar) {\n                toolbarWidget.addItem(name, widget);\n                if (widget instanceof _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.ReactWidget &&\n                    widget.renderPromise !== undefined) {\n                    widget.update();\n                    promises.push(widget.renderPromise);\n                }\n            }\n            // Wait for all the buttons to be rendered before attaching the toolbar.\n            Promise.all(promises)\n                .then(() => {\n                toolbarWidget.addClass(CELL_TOOLBAR_CLASS);\n                cell.layout.insertWidget(0, toolbarWidget);\n                // For rendered markdown, watch for resize events.\n                cell.displayChanged.connect(this._resizeEventCallback, this);\n                // Watch for changes in the cell's contents.\n                cell.model.contentChanged.connect(this._changedEventCallback, this);\n                // Hide the cell toolbar if it overlaps with cell contents\n                this._updateCellForToolbarOverlap(cell);\n            })\n                .catch(e => {\n                console.error('Error rendering buttons of the cell toolbar: ', e);\n            });\n        }\n    }\n    _getCell(model) {\n        var _a;\n        return (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.widgets.find(widget => widget.model === model);\n    }\n    _findToolbarWidgets(cell) {\n        const widgets = cell.layout.widgets;\n        // Search for header using the CSS class or use the first one if not found.\n        return widgets.filter(widget => widget.hasClass(CELL_TOOLBAR_CLASS)) || [];\n    }\n    _removeToolbar(model) {\n        const cell = this._getCell(model);\n        if (cell) {\n            this._findToolbarWidgets(cell).forEach(widget => {\n                widget.dispose();\n            });\n            // Attempt to remove the resize and changed event handlers.\n            cell.displayChanged.disconnect(this._resizeEventCallback, this);\n        }\n        model.contentChanged.disconnect(this._changedEventCallback, this);\n    }\n    /**\n     * Call back on settings changes\n     */\n    _onToolbarChanged() {\n        var _a;\n        // Reset toolbar when settings changes\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell) {\n            this._removeToolbar(activeCell.model);\n            this._addToolbar(activeCell.model);\n        }\n    }\n    _changedEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _resizeEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _updateCellForToolbarOverlap(activeCell) {\n        // When we do change in cell, If we don't wait the browser might not have\n        // completed the layout update, resulting in the previous width being returned\n        // using `getBoundingClientRect().width` in later functions.\n        requestAnimationFrame(() => {\n            // Remove the \"toolbar overlap\" class from the cell, rendering the cell's toolbar\n            const activeCellElement = activeCell.node;\n            activeCellElement.classList.remove(TOOLBAR_OVERLAP_CLASS);\n            if (this._cellToolbarOverlapsContents(activeCell)) {\n                // Add the \"toolbar overlap\" class to the cell, completely concealing the toolbar,\n                // if the first line of the content overlaps with it at all\n                activeCellElement.classList.add(TOOLBAR_OVERLAP_CLASS);\n            }\n        });\n    }\n    _cellToolbarOverlapsContents(activeCell) {\n        var _a;\n        const cellType = activeCell.model.type;\n        // If the toolbar is too large for the current cell, hide it.\n        const cellLeft = this._cellEditorWidgetLeft(activeCell);\n        const cellRight = this._cellEditorWidgetRight(activeCell);\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        if (toolbarLeft === null) {\n            return false;\n        }\n        // The toolbar should not take up more than 50% of the cell.\n        if ((cellLeft + cellRight) / 2 > toolbarLeft) {\n            return true;\n        }\n        if (cellType === 'markdown' && activeCell.rendered) {\n            // Check for overlap in rendered markdown content\n            return this._markdownOverlapsToolbar(activeCell);\n        }\n        // Check for overlap in code content\n        if (((_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.renderingLayout) === 'default') {\n            return this._codeOverlapsToolbar(activeCell);\n        }\n        else {\n            return this._outputOverlapsToolbar(activeCell);\n        }\n    }\n    /**\n     * Check for overlap between rendered Markdown and the cell toolbar\n     *\n     * @param activeCell A rendered MarkdownCell\n     * @returns `true` if the first line of the output overlaps with the cell toolbar, `false` otherwise\n     */\n    _markdownOverlapsToolbar(activeCell) {\n        const markdownOutput = activeCell.inputArea; // Rendered markdown appears in the input area\n        if (!markdownOutput) {\n            return false;\n        }\n        // Get the rendered markdown as a widget.\n        const markdownOutputWidget = markdownOutput.renderedInput;\n        const markdownOutputElement = markdownOutputWidget.node;\n        const firstOutputElementChild = markdownOutputElement.firstElementChild;\n        if (firstOutputElementChild === null) {\n            return false;\n        }\n        // Temporarily set the element's max width so that the bounding client rectangle only encompasses the content.\n        const oldMaxWidth = firstOutputElementChild.style.maxWidth;\n        firstOutputElementChild.style.maxWidth = 'max-content';\n        const lineRight = firstOutputElementChild.getBoundingClientRect().right;\n        // Reinstate the old max width.\n        firstOutputElementChild.style.maxWidth = oldMaxWidth;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _outputOverlapsToolbar(activeCell) {\n        const outputArea = activeCell.outputArea.node;\n        if (outputArea) {\n            const outputs = outputArea.querySelectorAll('[data-mime-type]');\n            const toolbarRect = this._cellToolbarRect(activeCell);\n            if (toolbarRect) {\n                const { left: toolbarLeft, bottom: toolbarBottom } = toolbarRect;\n                return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.some)(outputs, output => {\n                    const node = output.firstElementChild;\n                    if (node) {\n                        const range = new Range();\n                        if (TEXT_MIME_TYPES.includes(output.getAttribute('data-mime-type') || '')) {\n                            // If the node is plain text, it's in a <pre>. To get the true bounding box of the\n                            // text, the node contents need to be selected.\n                            range.selectNodeContents(node);\n                        }\n                        else {\n                            range.selectNode(node);\n                        }\n                        const { right: nodeRight, top: nodeTop } = range.getBoundingClientRect();\n                        // Note: y-coordinate increases toward the bottom of page\n                        return nodeRight > toolbarLeft && nodeTop < toolbarBottom;\n                    }\n                    return false;\n                });\n            }\n        }\n        return false;\n    }\n    _codeOverlapsToolbar(activeCell) {\n        const editorWidget = activeCell.editorWidget;\n        const editor = activeCell.editor;\n        if (!editorWidget || !editor) {\n            return false;\n        }\n        if (editor.lineCount < 1) {\n            return false; // Nothing in the editor\n        }\n        const codeMirrorLines = editorWidget.node.getElementsByClassName('cm-line');\n        if (codeMirrorLines.length < 1) {\n            return false; // No lines present\n        }\n        let lineRight = codeMirrorLines[0].getBoundingClientRect().left;\n        const range = document.createRange();\n        range.selectNodeContents(codeMirrorLines[0]);\n        lineRight += range.getBoundingClientRect().width;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _cellEditorWidgetLeft(activeCell) {\n        var _a, _b;\n        return (_b = (_a = activeCell.editorWidget) === null || _a === void 0 ? void 0 : _a.node.getBoundingClientRect().left) !== null && _b !== void 0 ? _b : 0;\n    }\n    _cellEditorWidgetRight(activeCell) {\n        var _a, _b;\n        return (_b = (_a = activeCell.editorWidget) === null || _a === void 0 ? void 0 : _a.node.getBoundingClientRect().right) !== null && _b !== void 0 ? _b : 0;\n    }\n    _cellToolbarRect(activeCell) {\n        const toolbarWidgets = this._findToolbarWidgets(activeCell);\n        if (toolbarWidgets.length < 1) {\n            return null;\n        }\n        const activeCellToolbar = toolbarWidgets[0].node;\n        return activeCellToolbar.getBoundingClientRect();\n    }\n    _cellToolbarLeft(activeCell) {\n        var _a;\n        return ((_a = this._cellToolbarRect(activeCell)) === null || _a === void 0 ? void 0 : _a.left) || null;\n    }\n}\nconst defaultToolbarItems = [\n    {\n        command: 'notebook:duplicate-below',\n        name: 'duplicate-cell'\n    },\n    {\n        command: 'notebook:move-cell-up',\n        name: 'move-cell-up'\n    },\n    {\n        command: 'notebook:move-cell-down',\n        name: 'move-cell-down'\n    },\n    {\n        command: 'notebook:insert-cell-above',\n        name: 'insert-cell-above'\n    },\n    {\n        command: 'notebook:insert-cell-below',\n        name: 'insert-cell-below'\n    },\n    {\n        command: 'notebook:delete-cell',\n        name: 'delete-cell'\n    }\n];\n/**\n * Widget extension that creates a CellToolbarTracker each time a notebook is\n * created.\n */\nclass CellBarExtension {\n    constructor(commands, toolbarFactory) {\n        this._commands = commands;\n        this._toolbarFactory = toolbarFactory !== null && toolbarFactory !== void 0 ? toolbarFactory : this.defaultToolbarFactory;\n    }\n    get defaultToolbarFactory() {\n        const itemFactory = (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.createDefaultFactory)(this._commands);\n        return (widget) => new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_1__.ObservableList({\n            values: defaultToolbarItems.map(item => {\n                return {\n                    name: item.name,\n                    widget: itemFactory(CellBarExtension.FACTORY_NAME, widget, item)\n                };\n            })\n        });\n    }\n    createNew(panel) {\n        return new CellToolbarTracker(panel, this._toolbarFactory(panel));\n    }\n}\nCellBarExtension.FACTORY_NAME = 'Cell';\n\n//# sourceMappingURL=celltoolbartracker.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/cell-toolbar/lib/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@jupyterlab/cell-toolbar/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CellBarExtension\": () => (/* reexport safe */ _celltoolbartracker__WEBPACK_IMPORTED_MODULE_0__.CellBarExtension),\n/* harmony export */   \"CellToolbarTracker\": () => (/* reexport safe */ _celltoolbartracker__WEBPACK_IMPORTED_MODULE_0__.CellToolbarTracker)\n/* harmony export */ });\n/* harmony import */ var _celltoolbartracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./celltoolbartracker */ \"../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module cell-toolbar\n */\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cell-toolbar/lib/index.js?");

/***/ })

}]);