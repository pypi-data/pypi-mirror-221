import os
import time
import uuid
import json
import sanic
import pickle
import hashlib
import sqlite3
import asyncio
import aiohttp
import argparse

APP = sanic.Sanic('kvlog')
APP.config.KEEP_ALIVE_TIMEOUT = 300


class SQLite():
    def __init__(self, db):
        d = hashlib.sha256(db.encode()).hexdigest()
        self.path = os.path.join('db', d[0:3], d[3:6], d + '.sqlite3')

        if not os.path.isfile(self.path):
            os.makedirs(os.path.dirname(self.path), exist_ok=True)

            tmp = os.path.join('db', str(uuid.uuid4()))

            db = sqlite3.connect(tmp)
            db.execute('''create table paxos(
                          key          text,
                          version      unsigned int,
                          promised_seq unsigned int,
                          accepted_seq unsigned int,
                          value        blob)''')
            db.execute('create unique index i0 on paxos(key, version)')
            db.commit()

            os.replace(tmp, self.path)

    def commit(self):
        self.db.commit()

    def __call__(self, query, *args):
        return self.db.execute(query, args).fetchall()

    def __enter__(self):
        self.db = sqlite3.connect(self.path)
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.db.rollback()
        self.db.close()


@APP.post('/<phase:str>/<db:str>/<key:str>/<version:int>/<proposal_seq:int>')
async def paxos_server(request, phase, db, key, version, proposal_seq):
    if ARGS.config['cluster_key'] != request.headers['x-cluster-key']:
        raise sanic.exceptions.Unauthorized('INVALID_CLUSTER_KEY')

    with SQLite(db) as sql:
        sql('insert or ignore into paxos values(?,?,0,0,null)', key, version)

        _, _, promised_seq, accepted_seq, value = sql(
            'select * from paxos where key=? and version=?', key, version)[0]

        # This is not part of the paxos protocol.
        #
        # This row is final, but some node might not have participated in this
        # paxos round. When it tries to run a new paxos round for this row,
        # other nodes just pretend to participate so that the paxos round can
        # be completed for that node.
        if promised_seq is None and accepted_seq is None:
            if 'promise' == phase:
                return response([999999999999999, value])

            if 'accept' == phase or 'learn' == phase:
                return response('OK')

        # Standard paxos protocol PROMISE phase
        if 'promise' == phase and proposal_seq > promised_seq:
            sql('update paxos set promised_seq=? where key=? and version=?',
                proposal_seq, key, version)
            sql.commit()

            return response([accepted_seq, value])

        # Standard paxos protocol ACCEPT phase
        if 'accept' == phase and proposal_seq == promised_seq:
            value = pickle.loads(request.body)

            sql('''update paxos
                   set accepted_seq=?, value=?
                   where key=? and version=?
                ''', proposal_seq, value, key, version)
            sql.commit()

            return response('OK')

        # Paxos protocol does not specify this phase.
        # If a value for the key is accepted by a majority, it is learned.
        #
        # Our paxos client, after a successful accept phase, runs another
        # round to mark the row as final.
        if 'learn' == phase and promised_seq == accepted_seq == proposal_seq:
            sql('''update paxos
                   set promised_seq=null, accepted_seq=null
                   where key=? and version=?
                ''', key, version)
            sql('delete from paxos where key=? and version < ?', key, version)
            sql.commit()

            return response('OK')

    raise sanic.exceptions.BadRequest('INVALID_SEQ_OR_UNKNOWN')


async def paxos_client(db, key, version, value):
    # paxos seq is an integer in the following format - YYYYmmddHHMMSS
    # This would increase monotonically. Even if same seq is generated by
    # more than one instances of paxos rounds, protocol handles it and rejects
    # the later round (as proposal_seq should be GREATER than the promised_seq)
    url = '{{}}/{}/{}/{}/{}'.format(
        db, key, version, time.strftime('%Y%m%d%H%M%S'))

    res = await rpc(url.format('promise'))
    if ARGS.quorum > len(res):
        return 'NO_PROMISE_QUORUM'

    # Find out the accepted value with the highest accepted_seq
    proposal = (0, value)
    for accepted_seq, val in res.values():
        if accepted_seq > proposal[0]:
            proposal = (accepted_seq, val)

    if not proposal[1]:
        return 'CANT_SET_EMPTY_VALUE'

    res = await rpc(url.format('accept'), proposal[1])
    if ARGS.quorum > len(res):
        return 'NO_ACCEPT_QUORUM'

    await rpc(url.format('learn'))

    return 'OK' if 0 == proposal[0] else 'CONFLICT'


@APP.put('/<db:str>/<key:str>/<version:int>')
async def PUT(request, db, key, version):
    status = await paxos_client(db, key, version, request.body)

    if 'OK' != status:
        raise sanic.exceptions.BadRequest(status)

    return sanic.response.json(status, headers={
        'x-db': db,
        'x-key': key,
        'x-version': version,
        'x-length': len(request.body)})


@APP.post('/max_version/<db:str>/<key:str>')
async def max_version(request, db, key):
    if ARGS.config['cluster_key'] != request.headers['x-cluster-key']:
        raise sanic.exceptions.Unauthorized('INVALID_CLUSTER_KEY')

    with SQLite(db) as sql:
        rows = sql('''select max(version) from paxos
                      where key=? and (accepted_seq != 0 or
                                       accepted_seq is null)
                   ''', key)

    return response(rows[0][0] if rows and rows[0][0] else 0)


@APP.get('/<db:str>/<key:str>')
async def GET(request, db, key):
    res = await rpc('max_version/{}/{}'.format(db, key))
    if ARGS.quorum > len(res):
        raise sanic.exceptions.BadRequest('NO_MAX_VERSION_QUORUM')

    version = max(res.values())

    if 0 == max_version:
        raise sanic.exceptions.NotFound('KEY_NOT_FOUND')

    for i in range(2):
        with SQLite(db) as sql:
            rows = sql('select * from paxos where key=? and version=?',
                       key, version)

        if rows and rows[0][2] is None and rows[0][3] is None:
            return sanic.response.raw(rows[0][4], headers={
                'x-db': db,
                'x-key': rows[0][0],
                'x-version': rows[0][1]})

        await paxos_client(db, key, version, None)

    raise sanic.exceptions.BadRequest('SYNC_FAILED')


def response(obj):
    return sanic.response.raw(pickle.dumps(obj))


async def rpc(url, obj=None):
    servers = ARGS.config['cluster_nodes']

    if not hasattr(rpc, 'session'):
        rpc.session = aiohttp.ClientSession(
            headers={'x-cluster-key': ARGS.config['cluster_key']},
            connector=aiohttp.TCPConnector(
                limit=1000, limit_per_host=1000, ssl=False))

    responses = await asyncio.gather(
        *[asyncio.ensure_future(rpc.session.post(
            '{}/{}'.format(srv, url), data=pickle.dumps(obj)))
          for srv in servers],
        return_exceptions=True)

    result = dict()
    for s, r in zip(servers, responses):
        if type(r) is aiohttp.client_reqrep.ClientResponse:
            if 200 == r.status:
                result[s] = pickle.loads(await r.read())

    return result


if '__main__' == __name__:
    DEFAULT_CONF = dict(
        cluster_key="supersecret",
        cluster_nodes=[
            "https://localhost:5001",
            "https://localhost:5002",
            "https://localhost:5003",
            "https://localhost:5004",
            "https://localhost:5005"],
        ssl_cert="cert.pem",
        ssl_key="key.pem")

    PARSER = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter)

    PARSER.add_argument('--bind', help='ip:port')
    PARSER.add_argument('--config', default='kvlog.json',
                        help='cluster config file in this format\n{}'.format(
                             json.dumps(DEFAULT_CONF, indent=4, sort_keys=4)))

    ARGS = PARSER.parse_args()

    with open(ARGS.config) as fd:
        ARGS.config = json.load(fd)
        ARGS.quorum = int(len(ARGS.config['cluster_nodes']) / 2) + 1

    HOST, PORT = ARGS.bind.split(':')
    SSL = None
    if 'ssl_cert' in ARGS.config:
        SSL = dict(names=["*"],
                   key=ARGS.config['ssl_key'],
                   cert=ARGS.config['ssl_cert'])

    APP.run(HOST, int(PORT), single_process=True, access_log=True, ssl=SSL)
