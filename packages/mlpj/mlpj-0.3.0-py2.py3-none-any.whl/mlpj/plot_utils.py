"""
Utilities and convenience functions for `matplotlib`
"""
import collections
import warnings
from typing import Optional, Any, Tuple

import contextlib
import numpy as np
from numpy.typing import ArrayLike
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib import gridspec

from . import numpy_utils as npu
from . import pandas_utils as pdu


LOWER_1_SIGMA_QUANTILE = (1. - 0.6827) / 2
LOWER_2_SIGMA_QUANTILE = (1. - 0.9545) / 2


@contextlib.contextmanager
def libstyle() -> None:
    """Context manager to set some `matplotlib` styles temporarily"""
    orig_params = list(mpl.rcParams.items())
    try:
        mpl.rcParams['grid.color'] = '#000000'
        mpl.rcParams['grid.alpha'] = 0.1
        mpl.rcParams['grid.linestyle'] = '-'
        mpl.rcParams['lines.markersize'] = 3.0
        mpl.rcParams['legend.numpoints'] = 1
        mpl.rcParams['legend.framealpha'] = 0.4

        # font sizes
        mpl.rcParams['font.size'] = 10
        mpl.rcParams['legend.fontsize'] = 'small'
        mpl.rcParams['axes.labelsize'] = 'small'
        mpl.rcParams['axes.titlesize'] = 'medium'
        mpl.rcParams['xtick.labelsize'] = 'small'
        mpl.rcParams['ytick.labelsize'] = 'small'

        # default interpolation of images, used in `plt.imshow`
        # if parameter `interpolation` is set to `None`
        #mpl.rcParams['image.interpolation'] = None
        yield
    finally:
        mpl.rcParams.clear()
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            mpl.rcParams.update(orig_params)


def xytitle(xlabel: str = None, ylabel: str = None, title: str = None) -> None:
    """Add labels for the x-axis, y-axis and / or the whole plot.
    
    Args:
        xlabel (str, optional): label for the x-axis
        ylabel (str, optional): label for the y-axis
        title (str, optional): label for the plot
    """
    if xlabel is not None:
        plt.xlabel(xlabel)
    if ylabel is not None:
        plt.ylabel(ylabel)
    if title is not None:
        plt.title(title)


def histogram_of_col(col: pd.Series) -> None:
    """Plot a histogram of the given column and add titles.

    Args:
        col (`pd.Series`): the data column to plot
    """
    colname = col.name
    #n_notnull = len(col[col.notnull()].drop_duplicates())
    #col.hist(bins=min(n_bins, n_notnull), backend='seaborn')
    #plt.hist(col.values, bins=min(n_bins, n_notnull), #align='right')
    plt.hist(col.values, bins='sqrt')
    xytitle(colname, "n", f"histogram of {colname}")


def plot_all_numerical_histograms(pj, df: pd.DataFrame, table_name: str
) -> None:
    """Plot the histograms of all numerical columns.

    Each plot will be generated unter the key
    `<table_name>_<colname>_histogram`.
    
    Args:
        pj (`project_utils.Manager`): project manager to handle the plots
        df (`pd.DataFrame`): Dataframe with the columns to plot
        table_name (str): name of the table for context
    """
    for colname in df.columns:
        col = df[colname]
        if pdu.is_numerical(col):
            if col.dtype.kind == 'b':
                col = col.astype(np.intp)
            with pj.savefig(f"{table_name}_{colname}_histogram"):
                histogram_of_col(col)

                
class PlotGrid(object):
    """Create a grid for matplotlib subplots.

    Subplot grids generated by this class can be nested into each other without
    the code for the inner plot grid having to be any different from the
    non-nested case. This makes complex plot functions more reusable.

    `matplotlib.gridspec.GridSpec` is used internally. The procedure
    described in http://matplotlib.org/users/gridspec.html is used to support
    nested `PlotGrid`s.

    Args:
        n_plots (int, optional) number of subplots to put in the grid; either
            this or `n_rows` must be specified
        n_rows (int, optional): number of rows to put in the grid; either this
            or `n_plots` must be specified
        n_cols (int): number of subplots per row
        For the other parameters, see `matplotlib.gridspec.GridSpec`.
    """
    def __init__(self, n_plots: int = None, n_rows: int = None, n_cols: int = None,
        width_ratios: ArrayLike = None, height_ratios: ArrayLike = None,
        wspace: Optional[float] =None, hspace: Optional[float] =None
    ):
        if n_cols is None:
            raise ValueError('n_cols is mandatory')

        if n_plots is not None and n_rows is None:
            n_rows = int(np.ceil(n_plots / n_cols))
        elif n_rows is not None and n_plots is None:
            n_plots = n_rows * n_cols

        self.n_plots = n_plots
        self.n_rows = n_rows
        self.n_cols = n_cols
        axes = plt.gca()
        self.containing_gridspec = get_containing_gridspec(axes)
        if self.containing_gridspec is None:
            self.gridspec = gridspec.GridSpec(
                self.n_rows, self.n_cols, width_ratios=width_ratios,
                height_ratios=height_ratios, wspace=wspace, hspace=hspace)
        else:
            axes.set_xticks([])
            axes.set_yticks([])
            self.gridspec = gridspec.GridSpecFromSubplotSpec(
                self.n_rows, self.n_cols, subplot_spec=self.containing_gridspec,
                width_ratios=width_ratios, height_ratios=height_ratios,
                wspace=wspace, hspace=hspace)

    def subplot(self, i_plot: int) -> mpl.axes.Axes:
        """Go to the i-th subplot and return the corresponding axes object.

        The attribute `containing_gridspec` is set in the `axes` object.
        This way, `get_containing_gridspec` can determine whether an
        `axes` object is contained in a `PlotGrid` or not and what its
        corresponding `gridspec` is.

        Args:
            i_plot (int): plot number
        Returns:
            `matplotlib.axes.Axes`: axes object of the i-th subplot in
            the grid
        """
        gridspec = self.gridspec[i_plot]
        if self.containing_gridspec is None:
            axes = plt.subplot(gridspec)
        else:
            figure = plt.gcf()
            axes = plt.Subplot(figure, gridspec)
            figure.add_subplot(axes)

        axes.containing_gridspec = gridspec
        return axes

    def update(self, **kwargs):
        """Update properties like `wspace, hspace` of the `PlotGrid`.

        This method delegates to `matplotlib.gridspec.GridSpec.update` of the
        internal `matplotlib.gridspec.GridSpec` object.
        """
        self.gridspec.update(**kwargs)
        

def get_containing_gridspec(axes: mpl.axes.Axes) -> mpl.gridspec.SubplotSpec:
    """Return the gridspec containing this axes object, if applicable.

    `PlotGrid.subplot` sets the attribute `containing_gridspec` in the
    subplot axes object to the corresponding gridspec item.

    Args:
        axes (`matplotlib.axes.Axes`): axes object of a subplot
    Returns:
        `matplotlib.gridspec.SubplotSpec` or `None`:
        If the axes object hasn't been created by `PlotGrid.subplot`,
        the result is None, otherwise it's the corresponding `gridspec` item.
    """
    if not hasattr(axes, 'containing_gridspec'):
        return None
    else:
        return axes.containing_gridspec

        
LOWER_1_SIGMA_QUANTILE = (1. - 0.6827) / 2
LOWER_2_SIGMA_QUANTILE = (1. - 0.9545) / 2


def histogram_plot(
        bin_contents: ArrayLike, bin_boundaries: ArrayLike,
        yscale: str = 'linear', orientation: str = 'vertical'
) -> None:
    """Plot a histogram for the given bin boundaries and bin contents.

    Args:
        bin_contents (series-like of shape `(n,)`): count for each bin.
        bin_boundaries (series-like of shape `(n + 1,)`): left and right
            boundaries for all bins
        yscale ('linear' | 'log'):
            'linear': normal linear scale for the `count` axis
            'log': logarithmic scale for the `count` axis
        orientation ('vertical' | 'horizontal'): orientation of the histogram
    """
    with libstyle():
        maximum_bin_content = max(bin_contents)
        bar_width = (bin_boundaries[1:] - bin_boundaries[:-1])
        center = (bin_boundaries[:-1] + bin_boundaries[1:]) / 2
    
        if yscale == 'linear':
            if orientation == 'vertical':
                plt.bar(center, bin_contents, align='center', width=bar_width,
                        color='b', edgecolor='b')
            else:
                plt.barh(center,
                         bin_contents,
                         align='center',
                         height=bar_width,
                         color='b',
                         edgecolor='b')
        else:
            if orientation == 'vertical':
                plotx, ploty = center, bin_contents
            else:
                # For horizontal plots just reverse the arguments.
                plotx, ploty = bin_contents, center
    
            plt.plot(plotx, ploty, 'o', color='b')
            if orientation == 'vertical':
                plt.gca().set_yscale('log')
            else:
                plt.gca().set_xscale('log')
            plt.grid(True, which='minor', alpha=0.8 * mpl.rcParams['grid.alpha'])
    
        count_max = maximum_bin_content + max(maximum_bin_content / 10., 1)
        count_min = 0
    
        if yscale == 'linear':
            count_max *= 1.08
        else:
            count_max *= 2
    
        if orientation == 'vertical':
            plt.ylim(count_min, count_max)
        else:
            plt.xlim(count_max, count_min)
            locs, labels = plt.xticks()
            plt.setp(labels, rotation=70)
    
    
def profile_plot(
        x: ArrayLike, y: ArrayLike, n_bins: int = 100, equal_n_datapoints: bool = False,
        n_ticks: int = 10, is_continuous_x: bool = True,
        errorbars: str = 'quantile', histogram: str = 'linear',
        density: Optional[str] = None, with_median: bool = True
) -> None:
    """Profile plot of one column versus another.
    
    The x-axis represents the values of `x`, the y-axis the values of `y`.
    For each x-bin, the distribution of y-values is visualized by this plot:
    the mean y (in blue), optionally the median y (in green), the 1-sigma error
    bar (in green) and the 2-sigma error bar (in yellow).
    
    Args:
        x (series-like): x values
        y (series-like): y values
        n_bins (int): number of bins
        equal_n_datapoints (bool): If `True`, `n_bins` bins with approximately
            equal number of data points are chosen instead of equidistant
            bins.
        n_ticks (int, optional): For `equal_n_datapoints`, this is the number of
             ticks displayed. If None, each bin has its own tick.
        is_continuous_x (bool): If there are only a few x values, set this
             to `False` to get nicer ticks.
        errorbars ('binomial' | 'quantile' | None): Display the errorbars
             for each bin.
    
             `'binomial'`: for binary y values (0 or 1).
             `'quantile'`: Quantiles according to the gaussian distribution`s
                  standard deviation are displayed.
                  * the range from `quantile((1. - 0.6827) / 2)` to
                    `quantile(1 - (1. - 0.6827) / 2)` as a green error bar.
                  * the range from `quantile((1. - 0.9545) / 2)` to
                   `quantile(1 - (1. - 0.9545) / 2)` as a yellow error bar.
             `'mean'`: errorbars for the mean of each bin (much narrower than
                  the above)
             `None` : No errorbars are plotted.
        histogram ('linear' | 'log' | None; or pair of such values): If this a
             tuple, the option refers to a histogram for the x-values and
             y-values, respectively. Otherwise only a histogram for the
             x-values is plotted.
    
            `'linear'`: normal linear scale for the `count` axis
            `'log'`: logarithmic scale for the `count` axis
            `None`: no histogram
        density ('scatter' | None): how to display the density of the samples.
            This is added transparently in the background. The combination of
            `density != None` and `equal_n_datapoints = True` hasn't been
            implemented yet.
        with_median (bool): If True, the medians are plotted as green dots.
    """
    with libstyle():
        if equal_n_datapoints and not is_continuous_x:
            raise ValueError("equal_n_datapoints is not"
                             " supported for non continuous x")
    
        errorbar_options = {"binomial", None, "quantile", "mean"}
        if errorbars not in errorbar_options:
            raise ValueError("Please choose on of {}".format(errorbar_options))
    
        if density and equal_n_datapoints:
            raise NotImplementedError(
                "The combination of the density and the equal_n_datapoints "
                "options hasn't been implemented yet.")
    
        x = np.asarray(x)
        y = np.asarray(y)
        if len(x) != len(y):
            raise ValueError(
                "The input arrays x and y must have the same length.")
    
        def test_nan(array, array_name):
            """Test array for NaN values and raise a ValuError.
    
            Args:
                array (series-like): the values to test
                array_name (str): name of the array
            """
            if npu.anynan(array):
                raise ValueError("NaN values found in {0} array."
                                 " Please remove them".format(array_name))
            
        test_nan(x, "x")
        test_nan(y, "y")
    
        if isinstance(histogram, tuple):
            histogram_x, histogram_y = histogram
        else:
            histogram_x = histogram
            histogram_y = None
    
        axes_main, axes_bottom, axes_right, original_axes = (
            _create_bottom_right_axes(
                equal_n_datapoints, histogram_x, histogram_y))
    
        if is_continuous_x:
            plt.grid(True)
            bins, counts = _profile_plot_continuous(
                x, y, n_bins, equal_n_datapoints, n_ticks, errorbars=errorbars,
                with_median=with_median)
        else:
            bins, counts = _profile_plot_discrete(x, y, errorbars=errorbars,
                                                  with_median=with_median)
    
        if density == 'scatter':
            plt.scatter(x, y, s=1, c='b', alpha=0.2)
            ylim_main = np.min(y), np.max(y)
            plt.ylim(ylim_main)
    
        xlim_main = plt.xlim()
        ylim_main = plt.ylim()
    
        ymin, ymax = ylim_main
        if ymin < ymax:
            padding = (ymax - ymin) * 0.015
            ymin -= padding
            ymax += padding
            ylim_main = ymin, ymax
            plt.ylim(ylim_main)
    
        x_locations, x_labels = plt.xticks()
        x_labels = [label.get_text() for label in x_labels]
        y_locations, y_labels = plt.yticks()
        y_labels = [label.get_text() for label in y_labels]
    
        def reduce_labels(labels):
            n_odd = len(labels) % 2
            return [('' if i % 2 == n_odd else label.get_text())
                    for i, label in enumerate(labels)]
    
        if histogram_x is not None:
            plt.sca(axes_bottom)
            histogram_plot(counts, bins, yscale=histogram_x)
            plt.xlim(xlim_main)
            if equal_n_datapoints:
                rotation = 70
            else:
                rotation = None
            if not all([label == '' for label in x_labels]):
                plt.xticks(x_locations, x_labels, rotation=rotation)
            else:
                plt.xticks(x_locations, rotation=rotation)
                
            plt.xlim(xlim_main)
    
            if histogram_x != 'log':
                # Avoid overlap of count labels.
                plt.gcf().canvas.draw()
    
                _set_yticks_and_labels(
                    axes_bottom, None, reduce_labels(axes_bottom.get_yticklabels()))
    
            axes_main.get_xaxis().set_ticklabels([])
    
        if histogram_y is not None:
            plt.sca(axes_right)
            counts, bins = np.histogram(y, bins=n_bins)
            histogram_plot(counts, bins, yscale=histogram_y,
                           orientation='horizontal')
            if not all([label == '' for label in y_labels]):
                plt.yticks(y_locations, y_labels)
            else:
                plt.yticks(y_locations)
                axes_right.get_yaxis().set_ticklabels([])
            plt.ylim(ylim_main)
    
            if histogram_y != 'log':
                # Avoid overlap of count labels.
                plt.gcf().canvas.draw()
                axes_right.set_xticklabels(
                    reduce_labels(axes_right.get_xticklabels()))
    
        plt.sca(axes_main)


def diagonal_plot_for_prediction(
        pred: ArrayLike, y: ArrayLike, n_bins: int = 100, n_ticks: int = 10,
        errorbars: str = 'quantile', xlabel: str = "Prediction",
        ylabel: str = "Truth", histogram: str ='linear',
        with_median: bool = True
) -> None:
    """Diagonal plot of a prediction on test data with median and error bars
    for 1 sigma ranges and 2 sigma ranges in each bin.

    The x-axis represents the predictions, the y-axis the true values in
    training or test data. For each prediction bin, the distribution of true
    values is visualized by this plot: the mean target (in blue), optionally
    the median target (in green), the 1-sigma error bar (in green) and the 2-sigma
    error bar (in yellow).
    
    The closer the points and the error bars lie to the diagonal, the better
    the prediction.

    Args:
        pred (series-like):
            In the regression case the float predictions for the target.
            In the classifier case the probability predictions for the target
            (in `sklearn` the second column of `predict_proba`)
        y (series-like): true values of the target
        n_bins (int): number of bins
        n_ticks (int, optional): For `equal_n_datapoints`, this is the number of
             ticks displayed. If None, each bin has its own tick.
        errorbars ('binomial' | 'quantile' | None): Display the errorbars
             for each bin.
    
             `'binomial'`: for binary classifications
             `'quantile'`: Quantiles according to the gaussian distribution`s
                  standard deviation are displayed.
                  * the range from `quantile((1. - 0.6827) / 2)` to
                    `quantile(1 - (1. - 0.6827) / 2)` as a green error bar.
                  * the range from `quantile((1. - 0.9545) / 2)` to
                   `quantile(1 - (1. - 0.9545) / 2)` as a yellow error bar.
             `None` : No errorbars are plotted.
        xlabel (str): The label for the x-axis.
        ylabel (str): The label for the y-axis.
        histogram ('linear' | 'log' | None): If non-None, draw a histogram of
            the `x` values at the bottom of the plot.
    
            'linear': normal linear scale for the `count` axis
            'log': logarithmic scale for the `count` axis
        with_median (bool): If True, the medians are plotted as green dots.
    """
    with libstyle():
        profile_plot(pred, y, n_bins=n_bins, n_ticks=n_ticks, is_continuous_x=True,
                     errorbars=errorbars, histogram=histogram,
                     with_median=with_median)
        # Draw the diagonal line:
        xmin, xmax = plt.xlim()
        plt.plot([xmin, xmax], [xmin, xmax], 'k', linewidth=0.4)
        # Axis labels:
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)


def _calc_statistics(
        x: ArrayLike, y: ArrayLike, errorbars: str
) -> Tuple[ArrayLike, ArrayLike, ArrayLike, ArrayLike]:
    """Calculate means, medians, errors, counts for each bin.
    
    Args:
        x (series-like): binned x-values
        y (series-like): y-values
        errorbars (str): See the same param in `profile_plot`.
    Returns:
        arrays: means, medians, errors, counts
    """
    groupby = pd.Series(y).groupby(x)
    means = groupby.mean()
    medians = groupby.median()
    counts = groupby.size()
    errors = None
    if errorbars == 'quantile':
        # Introduces scipy warning: DeprecationWarning: using non-integer
        # number instead of an integer number
        with warnings.catch_warnings(record=False):
            warnings.simplefilter("ignore")
            errors = [groupby.quantile(LOWER_1_SIGMA_QUANTILE),
                      groupby.quantile(1 - LOWER_1_SIGMA_QUANTILE),
                      groupby.quantile(LOWER_2_SIGMA_QUANTILE),
                      groupby.quantile(1 - LOWER_2_SIGMA_QUANTILE)]
        errors = [series - medians for series in errors]
    elif errorbars == 'mean':
        sqrt_counts = np.sqrt(counts)
        errors = [
            (groupby.quantile(LOWER_1_SIGMA_QUANTILE) - means) / sqrt_counts,
            (groupby.quantile(1 - LOWER_1_SIGMA_QUANTILE) - means)
            / sqrt_counts]
    # elif errorbars == 'gaussian':
    #     std_y = np.std(y)
    #     groupby_squared = pd.Series(np.square(y)).groupby(x)
    #     errors = gaussian_errors(groupby, groupby_squared, std_y)
    elif errorbars == 'binomial':
        n = groupby.size()
        k = groupby.aggregate(np.sum)  # y = 1 or y = 0
        prior = 1
        errors = npu.beta_posterior_uncertainty(k, n, prior, prior)
    return means, medians, errors, counts
    

def _profile_plot_discrete(
        x: ArrayLike, y: ArrayLike, errorbars: str,
        with_median: bool = True
) -> None:
    """Profile plot implementation for discrete x-values.

    Args:
        x (series-like): x-values
        y (series-like): y-values
        errorbars (str): See the same param in `profile_plot`.
    """
    with libstyle():
        x = np.asarray(x)
        means, medians, errors, counts = _calc_statistics(x, y, errorbars)
        bin_boundaries = np.arange(len(means) + 1)
        bin_centers = (bin_boundaries[:-1] + bin_boundaries[1:]) / 2
        locations, labels = bin_centers, means.index
        plt.xticks(locations, labels)
        xmin = 0
        xmax = len(means) + 0.5
        plt.xlim(xmin, xmax)
        _plot_bin_results(bin_centers, means.values, medians.values,
                          np.asarray(errors), errorbars, with_median=with_median)
        return bin_boundaries, np.asarray(counts)


def _reduce_xticks(
        locations: ArrayLike, labels: ArrayLike, n_ticks: int
) -> Tuple[ArrayLike, ArrayLike]:
    """Recduce the number of ticks to plot.

    Args:
        locations (series-like): locations of the bins
        labels (series-like): tick labels for the bins
        n_ticks (int, optional): number of ticks

    Returns:
        arrays: chosen_locations, chosen_labels
    
    >>> locations = [2, 4, 7, 10]
    >>> labels = [1, 2, 3, 4]
    >>> assert (_reduce_xticks(locations, labels, 2) ==
    ...     ([2, 7, 10], [1.0, '', 4.0]))
    """
    if n_ticks is None:
        tickstep = 1
    else:
        tickstep = max(1, len(locations) // n_ticks)

    chosen_locations = []
    chosen_labels = []
    n = len(locations)

    def add_entry(i):
        chosen_locations.append(locations[i])
        chosen_labels.append(round(labels[i], 3))

    for i in range(0, n, tickstep):
        add_entry(i)

    if n - 1 % tickstep != 0:
        chosen_labels.pop()
        chosen_labels.append('')
        add_entry(n - 1)

    return chosen_locations, chosen_labels


def _profile_plot_continuous(
        x: ArrayLike, y: ArrayLike, n_bins: int, equal_n_datapoints: bool,
        n_ticks: int, errorbars: str, with_median: bool = True
) -> None:
    """Profile plot implementation for continuous x-values.

    Args:
        See `profile_plot` for the params with the same names.
    """
    with libstyle():
        if equal_n_datapoints:
            bin_boundaries = npu.bins_equal_n_datapoints(x, n_bins)
            equally_spaced_bin_boundaries = np.arange(len(bin_boundaries))
            bin_centers = 0.5 * (
                equally_spaced_bin_boundaries[:-1] +
                equally_spaced_bin_boundaries[1:])
            label_bincenters = 0.5 * (bin_boundaries[1:] +
                                      bin_boundaries[:-1])
            locations, labels = _reduce_xticks(
                bin_centers, label_bincenters, n_ticks)
            plt.xticks(locations, labels, rotation=70)
        else:
            minx, maxx = np.min(x), np.max(x)
            bin_boundaries = np.linspace(minx, maxx, n_bins + 1)
            bin_centers = 0.5 * (bin_boundaries[1:] +
                                 bin_boundaries[:-1])
    
        bin_numbers = npu.digitize(x, bin_boundaries)
        if equal_n_datapoints:
            bin_boundaries = equally_spaced_bin_boundaries
    
        means, medians, errors, counts = _calc_statistics(
            bin_numbers, y, errorbars)
        bin_centers = bin_centers[
            np.where(~np.isnan(means.reindex(np.arange(1, n_bins + 1))))]
        assert len(means) == len(bin_centers)
        _plot_bin_results(bin_centers, means.values, medians.values,
                          np.asarray(errors), errorbars, with_median=with_median)
        counts = counts.reindex(np.arange(1, n_bins + 1))
        counts = counts.fillna(0)
    
        plt.xlim([2 * bin_boundaries[0] - bin_centers[0],
                  2 * bin_boundaries[-1] - bin_centers[-1]])
        
        if not equal_n_datapoints:
            assert len(bin_boundaries) == len(counts) + 1
        return bin_boundaries, np.asarray(counts)

    
def _create_bottom_right_axes(
        equal_n_datapoints: bool, histogram_x: str, histogram_y: bool
) -> Tuple[mpl.axes.Axes, mpl.axes.Axes, mpl.axes.Axes,
     mpl.axes.Axes] :
    """Create axes objects for the bottom and/or the right of the current axes.

    Args:
        equal_n_datapoints (bool): If `True`, bins with approximately equal
            number of data points are chosen instead of equidistant bins.
        histogram_x (str or `None`): the kind of histogram to plot for the x-axis;
            see param `histogram` in `profile_plot`.
        histogram_y (str or `None`): the kind of histogram to plot for the y-axis;
            see param `histogram` in `profile_plot`.
    Returns:
        axes_main, axes_bottom, axes_right, original_axes
    """
    original_axes = plt.gca()

    if histogram_x is None and histogram_y is None:
        return original_axes, None, None, original_axes

    if histogram_x is not None:
        n_rows = 2
        height_ratios = [5 / 6, 1 / 6]
    else:
        n_rows = 1
        height_ratios = None

    if histogram_y is not None:
        n_cols = 2
        width_ratios = [6 / 7, 1 / 7]
    else:
        n_cols = 1
        width_ratios = None

    grid = PlotGrid(n_rows=n_rows,
                    n_cols=n_cols,
                    height_ratios=height_ratios,
                    width_ratios=width_ratios,
                    wspace=0)
    axes_main = grid.subplot(0)

    next_index = 1
    if histogram_y is not None:
        axes_right = grid.subplot(next_index)
        next_index = 2
        axes_right.grid(True)
    else:
        axes_right = None

    if histogram_x is not None:
        axes_bottom = grid.subplot(next_index)
        axes_bottom.grid(True)
    else:
        axes_bottom = None

    plt.sca(axes_main)
    return axes_main, axes_bottom, axes_right, original_axes


def _set_yticks_and_labels(axis: mpl.axes.Axes, y_ticks: ArrayLike,
                         y_ticklabels: ArrayLike) -> None:
    """Workaround to set yticks and labels.
    
    https://stackoverflow.com/questions/63723514/userwarning-fixedformatter-should-only-be-used-together-with-fixedlocator
    """
    if y_ticks is None:
        y_ticks = axis.get_yticks()
    axis.set_yticks(y_ticks)
    axis.set_yticklabels(y_ticklabels)


def _plot_bin_results(
        x: ArrayLike, means: ArrayLike, medians: ArrayLike,
        errors: ArrayLike, errorbars: str, with_median: bool = True
) -> None:
    """Plot results for each bin

    Args:
        x (array-like, shape `(n,)): binned x-values
        means (array-like, shape `(n,)): mean of y for each x-bin
        medians (array-like, shape `(n,)): median of y for each x-bin
        errors (array-like, shape `(n, 4)): boundaries of 1-sigma and 2-sigma
            error bars of y for each x-bin
        errorbars ('binomial' | 'quantile' | None): See `profile_plot`
        with_median (bool): If True, the medians are plotted.
    """
    ylim = means.min(), means.max()
    if with_median:
        ylim = np.minimum(ylim[0], medians.min()), np.maximum(ylim[1], medians.max())
    plt.ylim(ylim)
    
    if errors is not None:
        if errorbars == 'quantile':
            plt.errorbar(x, medians,
                         yerr=[-errors[2], errors[3]], fmt="none",
                         ecolor='gold', capsize=2.5)
            plt.errorbar(x, medians,
                         yerr=[-errors[0], errors[1]], fmt="none", ecolor='g',
                         capsize=2.5)
        elif errorbars == 'mean':
            plt.errorbar(x, means.values,
                         yerr=[-errors[0], errors[1]], fmt="-", ecolor='k',
                         capsize=2.5)
        else:
            plt.errorbar(x, means, yerr=errors,
                         fmt="o", ecolor='b', capsize=2.5)

    pmean, = plt.plot(x, means, 'o-', color='b')
    
    if with_median:
        pmedian, = plt.plot(x, medians, 'o', color='g')
        plt.legend([pmean, pmedian], ["mean", "median"], loc=0)
