import re
import typing
from functools import wraps

import flask
import structlog

from src.beckett.renderer.typescript_react.renderer import (
    build_render_context_for_base_template,
    write_react_page_file,
    write_typescript_file,
)
from src.beckett.types import NoneType, generate_interfaces
from src.beckett.types.types_manager import generate_api_decorator

log = structlog.get_logger(__name__)


class BeckettBlueprint(flask.Blueprint):
    """
    Handles the strong-linking between Flask view functions
    and React pages.
    """

    class page:
        """
        Decorate a flask endpoint such that the response will be a page rendered with a React component.

        Example:

            beckett = BeckettBlueprint()

            class PreferencesProps(PageProps):
                max_widgets: int

            @beckett.route("/get-preferences")
            @beckett.page()
            def preferences() -> PreferencesProps:
                return PreferencesProps(
                    max_widgets=4,
                )

        The return value must be a src.beckett.types.PageProps class.
        It will be transformed into props for the React page.
        """

        template: str

        def __init__(self):
            self.template = "beckett_page.jinja2"

        def __call__(self, view_function):
            from src.beckett.types.types_manager import api_route_type_manager

            self.view_function = view_function
            self.view_function_types = typing.get_type_hints(self.view_function)
            self.return_type = self.view_function_types.pop("return", None)
            self.module = re.sub(r".*\.", "", view_function.__module__)
            self.name = view_function.__name__

            # At server start, write out the typescript type file for the props, if the view function returns them.
            self._write_typescript_type_file()

            @wraps(view_function)
            def wrapped(*args, **kwargs):
                """Handles a request to the endpoint that the view function is serving.

                Outputs a standard templated flask response, using a template that renders a React component.
                """
                response = view_function(*args, **kwargs)

                react_context = {
                    "react_entrypoint_filename": f"src/js/template/{self.module}/{self.name}.tsx",
                    "base_data": {
                        "urlMap": api_route_type_manager.get_url_map(),
                    },
                }

                html = flask.render_template(
                    self.template,
                    __render_react_response=response,
                    props=response.model_dump_json(),
                    **build_render_context_for_base_template(),
                    **react_context,
                )
                status = 200
                headers = {
                    "Content-Type": "text/html; charset=utf-8",
                }

                return html, status, headers

            return wrapped

        def _write_typescript_type_file(self):
            if self.return_type == NoneType:
                return
            assert getattr(self.return_type, "__pydantic_complete__", False), (
                f"Endpoint {self.module}.{self.name} missing pydantic return annotation (which is required by"
                f"@beckett.page())."
            )
            write_react_page_file(module=self.module, endpoint=self.name)
            write_typescript_file(
                type_data=self._generate_typescript_type_file_contents(),
                module=self.module,
                endpoint=self.name,
            )

        def _generate_typescript_type_file_contents(self) -> str:
            typescript_imports, typescript_interfaces = generate_interfaces(
                self.return_type, name="PageProps", default_export=True
            )

            export_string = "// This file is generated by @beckett.page(), changes will be overwritten if the server is running in development mode\n\n"  # noqa

            if typescript_imports:
                export_string += typescript_imports.render()
                export_string += "\n"

            export_string += typescript_interfaces.render()

            return export_string.strip() + "\n"

    def api_get(self, rule, *, endpoint=None, **options):
        if "methods" in options:
            raise Exception("Can't specify method for api_get")

        def decorator(f):
            actual_endpoint = endpoint or f.__name__
            handle_api_route = generate_api_decorator(
                f,
                method="GET",
                endpoint=f"{self.name}.{actual_endpoint}",
                url=self.url_prefix + rule,
            )

            return self.add_url_rule(
                rule,
                view_func=handle_api_route,
                methods=["GET"],
                endpoint=actual_endpoint,
                **options,
            )

        return decorator

    def api_post(self, rule, *, endpoint=None, **options):
        if "methods" in options:
            raise Exception("Can't specify method for api_post")

        def decorator(f):
            actual_endpoint = endpoint or f.__name__
            handle_api_route = generate_api_decorator(
                f,
                method="POST",
                endpoint=f"{self.name}.{actual_endpoint}",
                url=self.url_prefix + rule,
            )

            return self.add_url_rule(
                rule,
                view_func=handle_api_route,
                methods=["POST"],
                endpoint=actual_endpoint,
                **options,
            )

        return decorator
