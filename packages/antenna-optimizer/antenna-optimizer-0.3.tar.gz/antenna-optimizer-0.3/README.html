<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Antenna Optimizer</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-12-21 16:51:22 +0100 (Fri, 21 Dec 2007) $
:Version: $Revision: 4316 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See <http://www.w3.org/TR/CSS1#the-cascade>. */
.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

a.reference img {
  border-width: 0px ;
  }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table.citation {
  border-left: solid thin gray }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid thin black }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

body {
  background-color: #F0F0FF }

p img {
  vertical-align: text-top }


</style>
</head>
<body>
<div class="document" id="antenna-optimizer">
<h1 class="title">Antenna Optimizer</h1>

<p>This project can optimize anntennas using genetic algorithms.  It uses
my <a class="reference external" href="https://pypi.org/project/PGAPy/">pgapy</a> Python wrapper for <a class="reference external" href="https://github.com/schlatterbeck/pgapack">PGApack</a>, the parallel genetic algorithm
library, originally by David Levine at Argonne National Laboratory and
currently maintained by me. It also uses <a class="reference external" href="https://pypi.org/project/PyNEC/">PyNEC</a>, the Python wrapper for
NEC2++, the C++ version of the <a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_Electromagnetics_Code">Numerical Electromagnetics Code</a>.</p>
<p>Originally this started out with a low-gain two-element antenna where
the driven element is a folded dipole. One of the requirements for that
antenna was that it should have 50&nbsp;Ω impedance and at least some
forward gain. Optimizing this antenna by hand soon turned out to be
tedious and I started experimenting with optimization by a genetic
algorithm.</p>
<p>You can find the original experiments in <tt class="docutils literal">folded.nec</tt> and
<tt class="docutils literal">folded2.nec</tt>. These are input files to the command-line NEC programs.
You can either use the <tt class="docutils literal">nec2c</tt> command-line program which produces an
output file that can be viewed with <tt class="docutils literal">xnecview</tt> or you can use
graphical <tt class="docutils literal">xnec2c</tt> program. All run under Linux and are included in
the Debian Linux distribution. The <tt class="docutils literal">.nec</tt> files <em>may</em> also be usable
with other NEC versions on other operating systems but I have not tried.</p>
<p>For optimizing the two-element Yagi-Uda you can use the command-line
tool <tt class="docutils literal">folded_antenna</tt> where the optimizer is implemented in
<tt class="docutils literal">folded.py</tt>. Later a 3-element antenna with the same principles was
added in <tt class="docutils literal">folded_3ele.py</tt> callable with the command-line tool
<tt class="docutils literal">folded_3ele_antenna</tt>.</p>
<p>The <tt class="docutils literal">antenna_model.py</tt> factors out the common parts of the various
antennas.</p>
<p>The <tt class="docutils literal">hb9cv.py</tt> with the command-line tool <tt class="docutils literal">hb9cv_antenna</tt> models the
well-know HB9CV antenna but only very crudely. NEC2 isn't really suited
for modelling the phasing stubs of that antenna because it doesn't like
parallel wires that are too close. I mainly did this for comparing some
of the antennas resulting from optimization with the well-known
performance of the HB9CV.</p>
<p>In the file <tt class="docutils literal">logper.py</tt> with the command-line tool <tt class="docutils literal">logper_antenna</tt>
you can find a 9-element log-periodic antenna.  It can currently not be
optimized, the performance of the real antenna is better than the
results obtained with NEC, so I didn't implement an optimizer for it
yet.</p>
<p>All the antenna programs take an action as mandatory argument. The
action is typically either <tt class="docutils literal">optimize</tt> for running the optimizer or
<tt class="docutils literal">necout</tt> for creating a <tt class="docutils literal">.nec</tt> file which can then be fed to one of
the nec programs mentioned above. When running the optimizer it makes
sense to experiment with different random seeds, each random seed will
usually produce a different antenna. In addition there are some
experimental actions, <tt class="docutils literal">frgain</tt> prints the forward and backward gains
(in dBi) for the lowest, the middle, and the highest frequencies and the
VSWR for those. The <tt class="docutils literal">gain</tt> action visualizes the 3D antenna gain
pattern and the <tt class="docutils literal">swr</tt> action visualizes the VSWR over the given
frequency range. Note that both, the <tt class="docutils literal">gain</tt> and the <tt class="docutils literal">swr</tt> action
compute the antenna data over the whole frequency range using NEC and
that may take some time.</p>
<p>The output of the optimizer is text (usually redirected to a file) that
prints the evaluation, the VSWR, maximum gain, and forward/backward
ratio of the best antenna for every 10th generation of the genetic
algorithm. In addition the command-line options to create that antenna
are printed. When the genetic algorithm doesn't make any more progress,
the search terminates and the data of the best evaluation are given. An
example of the last lines of such a text is as follows. The data is from
one of the best 2-element antennas was obtained with the random seed 26
of an earlier version of the program:</p>
<pre class="literal-block">
The Best Evaluation: 2.886437e+02.
The Best String:
-r 0.0364 -d 0.0444 -l 0.1704 -4 0.1075
VSWR: [1.7901433511443068, 1.1495780609982815, 1.7995760521232753]
GMAX: 6.69913175227, RMAX: -3.03663376703
Cache hits: 5670/9243 61.34%
Eval: 288.64
[ 101011001100101001111000000010011 ]
</pre>
<p>This tells us the evaluation (which is meaningful only to the
genetic algorithm), the genetic algorithm <em>maximizes</em> this value.
The command-line options after the line <tt class="docutils literal">The Best String:</tt> can be used
to create a <tt class="docutils literal">.nec</tt> file for that antenna. The antenna in the example
has a voltage standing wave ratio of &lt;&nbsp;1.8 at the band ends and
around 1.15 in the middle of the band (the 70cm band from 430 to
440&nbsp;MHz in that case). The forward gain (in the middle of the band)
is 6.7&nbsp;dBi. The RMAX value is the (maximum) backward gain (in a 30
degree area in the back). So the F/B ratio of that antenna is:</p>
<pre class="literal-block">
6.7 dB - -3.0 dB = 9.7 dB
</pre>
<p>The last line of the text output contains the genetic representation of
that antenna.
The <tt class="docutils literal">.nec</tt> file for the antenna above which was optimized with an early
version of this package can be created with the command:</p>
<pre class="literal-block">
folded_antenna -r 0.0364 -d 0.0444 -l 0.1704 -4 0.1075 necout &gt; folded-opt.nec
</pre>
<p>The command-line options specify the radius of the folded dipole, the
distance of the reflector from the folded dipole, the (half) length of
the reflector, and the (half) length of the straight part of the folded
dipole, respectively.</p>
<p>According to NEC it has a standing wave ratio (VSWR) of &lt;&nbsp;1.8 from
430-440&nbsp;MHz, a forward gain of &gt;&nbsp;6.5 dBi over the whole
frequency range and a Forward/Back Ratio of 8-11 dB.</p>
<p>If you want to implement an optimizer for your own antenna, look at the
file <tt class="docutils literal">folded.py</tt>: You need to implement a class that defines the
geometry of the new antenna and an optimizer class that initializes the
gene ranges and implements a <tt class="docutils literal">compute_antenna</tt> method that returns an
instance of your antenna class with the parameters obtained from the
given gene. All lengths in the models are metric (in meters) as is the
default in NEC.</p>
<p>A recent addition to this package involves modelling of coax cables.
This uses information from an old article by Frank Witt <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a> to derive
everything necessary to model a transmission line <em>with</em> loss from the
manufacturer cable data. The command-line tool for using these coax
models is named <tt class="docutils literal">coaxmodel</tt>. Again this command has several
sub-commands:</p>
<ul class="simple">
<li><tt class="docutils literal">loss</tt>: This displays the fitted loss-curves from the manufacturer
data against the curve-fit algorithm used, you can see how much
difference in dB the fitted curve has to the loss at certain
frequencies given by the manufacturer data.</li>
<li><tt class="docutils literal">match</tt> computes the impedance at the load and input (depending on
which was given as an input the other is computed), the matched and
total loss (the matched loss is the loss in the cable if the load is
prefectly matched, the total loss is the sum of the matched loss and
the additional loss due to reflections), the SWR and data for various
stub-matches to get to the cable impedance Z0.</li>
<li><tt class="docutils literal">resonator</tt> computes the resistance and Q-factor of a coax resonator
at the given frequency. A resonator is a piece of cable that either
has a short-circuit or an open-circuit at the far end. The sub-command
computes resonators for quarter and half wave at the given frequency.</li>
<li><tt class="docutils literal">stub</tt> computes the length, Q-factor, and resulting impedance as
well as the inductance or capacitance of a stub for a given impedance
and frequency. The impedance by default is -100j Ohm and can be
changed with the -x option. The stub with the shortest resulting
length is chosen, so for a negative reactance an open stub is chosen
while for a positive reactance a closed stub is chosen.</li>
</ul>
<p>For all these sub-commands you can specify the frequency, length of
cable and impedance (either at the load or at the end of the cable) to
be used in computing the results. You can specify complex impedances as
a python complex number in the format a+bj, e.g. 50-500j.</p>
<p>Finally the <tt class="docutils literal">transmission_line</tt> program can optimize the stub-matching
for a transmission line using NEC. By default a lossless line is asumed.
Also by default a closed stub at the closest possible position is
searched.</p>
<p>Transmission lines can be modelled by NEC with the <tt class="docutils literal">TL</tt> (transmission
line) card.  But NEC can also model arbitrary (symmetric, passive)
networks with the <tt class="docutils literal">NT</tt> (network) card. We use this (and the code in
<tt class="docutils literal">coaxmodel.py</tt>) to model a real cable <em>with loss</em> for stub matching.
It is instructive to compare the values for stub-matching obtained
analytically from <tt class="docutils literal">coaxmodel</tt> with the values obtained from an
optimization with the genetic algorithm by <tt class="docutils literal">transmission_line</tt>. Note
that the coaxmodel takes frequecies in Hz while transmission_line (which
uses NEC) accepts frequencies in MHz. So we match a complex impedance of
75+15j Ω for example:</p>
<pre class="literal-block">
coaxmodel -c sytronic_RG_58_CU -f 435e6 -z 75+15j match
</pre>
<p>This yields a stub of length 8.007 cm attached 7.888 cm from the load when
matching with a closed stub. When optimizing with <tt class="docutils literal">transmission_line</tt>:</p>
<pre class="literal-block">
transmission_line -c sytronic_RG_58_CU -f 435 -z 75+15j optimize
</pre>
<p>we get 8.016cm for the stub length and 7.6cm for the distance of the
stub from the load. We can visualize this over a given frequency range
by either producing NEC output:</p>
<pre class="literal-block">
transmission_line -c sytronic_RG_58_CU -f 435 -z 75+15j -i 50 \
   -l 0.0816 -d 0.076 --frqstart=430 --frqend=440 necout &gt; x1.nec
transmission_line -c sytronic_RG_58_CU -f 435 -z 75+15j -i 50 \
   -l 0.08007 -d 0.07888 --frqstart=430 --frqend=440 necout &gt; x2.nec
</pre>
<p>And the compute the nec model and display with:</p>
<pre class="literal-block">
nec2c -i x1.nec &gt; x1.out
nec2c -i x2.nec &gt; x2.out
xnecview x1.out
xnecview x2.out
</pre>
<p>Or directly display the VSWR curves with:</p>
<pre class="literal-block">
transmission_line -c sytronic_RG_58_CU -f 435 -z 75+15j -i 50 \
   -l 0.0816 -d 0.076 --frqstart=430 --frqend=440 swr
transmission_line -c sytronic_RG_58_CU -f 435 -z 75+15j -i 50 \
   -l 0.08007 -d 0.07888 --frqstart=430 --frqend=440 swr
</pre>
<p>Both are close enough, the SWR is below 1.1 over the whole frequency
range given. Note that this can change drastically if load impedances
with a higher VSWR are matched.</p>
<p>Also note that the NEC files produced in the example above have a different
NEC network <em>for each frequency</em>. This is because NEC models networks
using an <a class="reference external" href="https://en.wikipedia.org/wiki/Admittance_parameters">admittance matrix</a> which is frequency dependent.</p>
<p>This means the sequence of two <tt class="docutils literal">NT</tt>
cards, a <tt class="docutils literal">TL</tt> card, a <tt class="docutils literal">FR</tt> card and a <tt class="docutils literal">RP</tt> card are repeated for
each frequency. Here the two <tt class="docutils literal">NT</tt> cards define the network of the
cable from the load to the stub and the stub itself while the <tt class="docutils literal">TL</tt>
card defines the length of a lossless transmission line from the stub to
the source. The <tt class="docutils literal">FR</tt> card specifies a single frequency and the <tt class="docutils literal">RP</tt>
card defines a radiation pattern and triggers computation. This format
is perfectly valid NEC code, but certain programs (like the popular
<tt class="docutils literal">xnec2c</tt>) cannot deal with this format and display only a single
frequency.</p>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Frank Witt. Transmission line properties from manufacturer’s
data. In R. Dean Straw, editor, The ARRL Antenna Compendium, volume 6,
pages 179–183. American Radio Relay League (ARRL), 1999.</td></tr>
</tbody>
</table>
<div class="section" id="changes">
<h1>Changes</h1>
<p>Version 0.3: Multi-objective optimization</p>
<ul class="simple">
<li>Switch to pyproject.toml instead of setup.py</li>
<li>Add multi-objective optimization</li>
<li>Allow NSGA-III for multi-objective optimization</li>
<li>Allow to model ground</li>
<li>Multiple frequency ranges</li>
<li>Allow to use average gain when optimizing. Needs a bug-fix in pynec
<a class="reference external" href="https://github.com/tmolteno/necpp/pull/73">https://github.com/tmolteno/necpp/pull/73</a></li>
<li>Add epsilon constrained optimization
This allows to better find areas with good gain even if constraining
the solutions to low SWR</li>
</ul>
<p>Version 0.2: More cable data</p>
<ul>
<li><p class="first">Fix setup to correctly specify dependencies</p>
</li>
<li><p class="first">Add more cable data the following command will list supported cable
types:</p>
<pre class="literal-block">
coaxmodel --help
</pre>
</li>
</ul>
<p>Version 0.1: Initial Release</p>
</div>
</div>
</body>
</html>
