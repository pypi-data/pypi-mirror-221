Index: illumigator/data/config.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"current_level\": 1, \"volume\": {\"master\": 0.5, \"music\": 0.5, \"effects\": 0.5}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumigator/data/config.json b/illumigator/data/config.json
--- a/illumigator/data/config.json	(revision dc0dff134c351e10305c1f00e7ec653152a28998)
+++ b/illumigator/data/config.json	(date 1690176527356)
@@ -1,1 +1,1 @@
-{"current_level": 1, "volume": {"master": 0.5, "music": 0.5, "effects": 0.5}}
\ No newline at end of file
+{"current_level": 4, "volume": {"master": 0.5, "music": 0.5, "effects": 0.5}}
\ No newline at end of file
Index: illumigator/data/levels/community/levels.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"levels\": {\"custom_level_test.json\": {\"date_modified\": 1689858543.3860767, \"level_name\": \"Custom Test Level\", \"planet_name\": \"earth\"}}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumigator/data/levels/community/levels.json b/illumigator/data/levels/community/levels.json
--- a/illumigator/data/levels/community/levels.json	(revision dc0dff134c351e10305c1f00e7ec653152a28998)
+++ b/illumigator/data/levels/community/levels.json	(date 1690176518145)
@@ -1,1 +1,1 @@
-{"levels": {"custom_level_test.json": {"date_modified": 1689858543.3860767, "level_name": "Custom Test Level", "planet_name": "earth"}}}
\ No newline at end of file
+{"levels": {"custom_level_test.json": {"date_modified": 1690175258.1521873, "level_name": "Custom Test Level", "planet_name": "earth"}}}
\ No newline at end of file
Index: illumigator/entity.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport arcade\r\nimport pyglet.media\r\nimport numpy\r\n\r\nfrom illumigator import util\r\n\r\n\r\nclass SpriteLoader:\r\n    \"\"\"\r\n    Sprites manager and Iterator for a specific direction\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    def reset(self):\r\n        self._index = -1\r\n\r\n    def get_stationary(self):\r\n        self.reset()\r\n        return next(self)\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __next__(self):\r\n        self._index = (self._index + 1) % len(self._sprites)\r\n        return self._sprites[self._index]\r\n\r\n    @property\r\n    def sprite_files(self):\r\n        return self._sprite_files\r\n\r\nclass PlayerSpriteLoader(SpriteLoader):\r\n    \"\"\"\r\n    Sprites manager and Iterator for a specific direction\r\n    \"\"\"\r\n\r\n    def __init__(self, direction, sprite_format_string: str = util.PLAYER_SPRITE, idle_sprite_format: str = util.PLAYER_IDLE_SPRITE, dead_sprite_format_string: str = util.PLAYER_DEAD_SPRITE):\r\n        self.suffix = direction\r\n        \r\n        self._sprites = []\r\n        self._sprite_files = []\r\n        self._index = -1\r\n        \r\n        self._dead_sprites = []\r\n        self._dead_index = -1\r\n        self._dead_frames_shown = 0\r\n        self.dead = False\r\n\r\n        self._idle_sprites = []\r\n        self._idle_index = -1\r\n        self.idle = True\r\n\r\n        for i in range(6):\r\n            fname = sprite_format_string.format(i=i, direction=direction)\r\n            self._sprite_files.append(fname)\r\n            sprite = util.load_texture(fname)\r\n            self._sprites.append(sprite)\r\n        \r\n        for i in range(1, 4):\r\n            fname = dead_sprite_format_string.format(i=i, direction=direction)\r\n            self._dead_sprites.append(util.load_texture(fname))\r\n        \r\n        for i in range(0, 3):\r\n            \r\n            fname = idle_sprite_format.format(i=i, direction=direction)\r\n            self._idle_sprites.append(util.load_texture(fname))\r\n\r\n        self.stationary = self._sprites[0]\r\n        \r\n    \r\n    def __next__(self):\r\n        if self.dead:\r\n            # Show last death sprite for a 5 frames\r\n            if self._dead_index > len(self._dead_sprites)-2:\r\n                if self._dead_frames_shown > 5:\r\n                    # If death animation over return None\r\n                    return None\r\n                self._dead_frames_shown += 1\r\n            else:\r\n                self._dead_index = (self._dead_index + 1) % len(self._dead_sprites)\r\n            return self._dead_sprites[self._dead_index]\r\n        elif self.idle:\r\n            if self._idle_index > len(self._idle_sprites)-2:\r\n                return self._idle_sprites[-1]\r\n            else:\r\n                self._idle_index = (self._idle_index + 1) % len(self._idle_sprites)\r\n            return self._idle_sprites[self._idle_index]\r\n        else:\r\n            self._idle_index = self._dead_index = -1\r\n            return super().__next__()\r\n\r\n\r\nclass EnemySpriteLoader(SpriteLoader):\r\n    \"\"\"\r\n    Sprites manager and Iterator for a specific direction\r\n    \"\"\"\r\n\r\n    def __init__(self, direction, sprite_format_string: str = util.ENEMY_SPRITE):\r\n        self.suffix = direction\r\n        self._sprites = []\r\n        self._sprite_files = []\r\n        self._index = -1\r\n        fnames = [sprite_format_string.format(i=i, direction=direction) for i in range(1, 5)]\r\n        for fname in fnames:\r\n            self._sprite_files.append(fname)\r\n            sprite = util.load_texture(fname)\r\n            self._sprites.append(sprite)\r\n        self.stationary = util.load_texture(util.ENEMY_SLEEP_SPRITE)\r\n\r\n\r\nclass Character:\r\n    def __init__(\r\n            self,\r\n            scale_factor=2,\r\n            image_width=24,\r\n            image_height=24,\r\n            walking_volume=1\r\n    ):\r\n\r\n        self.world_object = None\r\n        self.status = None\r\n        self.left_character_loader = PlayerSpriteLoader(\"left\")\r\n        self.right_character_loader = PlayerSpriteLoader(\"right\")\r\n\r\n        # To check if gator is idle\r\n        self.last_movement_timestamp = time.time()\r\n\r\n        self.character_sprite = util.load_sprite(\r\n            self.right_character_loader._sprite_files[0],\r\n            scale_factor,\r\n            image_width=image_width,\r\n            image_height=image_height,\r\n            hit_box_algorithm=\"Simple\",\r\n        )\r\n\r\n        self.left = False\r\n        self.right = False\r\n        self.up = False\r\n        self.down = False\r\n\r\n        self.mirror_in_reach = None\r\n        self.rotation_dir = 0\r\n        self.player = pyglet.media.player.Player()\r\n\r\n        self.walking_sound = util.load_sound(\"new_walk.wav\")\r\n        self.rotation_factor = 0\r\n\r\n        self.walking_volume = walking_volume\r\n\r\n    def draw(self):\r\n        if self.mirror_in_reach is not None:\r\n            self.mirror_in_reach.draw_outline()\r\n        self.character_sprite.draw(pixelated=True)\r\n\r\n    def update(self, level, walking_volume, enemy):\r\n        self.walking_volume = walking_volume\r\n\r\n        # Idle state animation\r\n        if any([self.up, self.down, self.left, self.right]):\r\n            self.last_movement_timestamp = time.time() \r\n            self.right_character_loader.idle = False\r\n            self.left_character_loader.idle = False\r\n        elif time.time() - self.last_movement_timestamp > util.PLAYER_IDLE_TIME:\r\n            # IDLE after PLAYER_IDLE_TIME seconds\r\n            self.right_character_loader.idle = True\r\n            self.left_character_loader.idle = True\r\n\r\n        # Walking. Return False if player died\r\n        if self.walk(level, enemy) is False:\r\n            return False\r\n\r\n        # Rotation\r\n        if self.rotation_dir == 0:\r\n            self.rotation_factor = 0\r\n        if self.rotation_factor < 3.00:\r\n            self.rotation_factor += 1 / 15\r\n\r\n        self.mirror_in_reach = self.get_mirror_in_reach(level)\r\n        if self.mirror_in_reach is not None:\r\n            self.mirror_in_reach.move_if_safe(\r\n                self,\r\n                numpy.zeros(2),\r\n                self.rotation_dir\r\n                * util.OBJECT_ROTATION_AMOUNT\r\n                * (2**self.rotation_factor),\r\n            )\r\n\r\n    def reset_pos(self, c_x, c_y):\r\n        self.character_sprite.center_x = c_x\r\n        self.character_sprite.center_y = c_y\r\n        # Makes sure character is facing right upon reset.\r\n        self.right_character_loader.reset()\r\n        self.status = None\r\n        self.character_sprite.texture = next(self.right_character_loader)\r\n    \r\n    def update_sprite(self, direction=None):\r\n        if self.right:\r\n            next_sprite = next(self.right_character_loader)\r\n            if next_sprite is None:\r\n                return False\r\n            self.character_sprite.texture = next_sprite\r\n            if direction is not None:\r\n                direction[0] += 1\r\n        if self.left:\r\n            next_sprite = next(self.left_character_loader)\r\n            if next_sprite is None:\r\n                return False\r\n            self.character_sprite.texture = next_sprite\r\n            if direction is not None:\r\n                direction[0] -= 1\r\n\r\n    def walk(self, level, enemy):\r\n        direction = numpy.zeros(2)\r\n        if getattr(self.right_character_loader, \"dead\", False):\r\n            if \"_right.png\" in self.character_sprite.texture.name:\r\n                self.right = True\r\n                self.left = False\r\n            else:\r\n                self.right = True\r\n                self.left = False\r\n\r\n        if self.update_sprite(direction) is False:\r\n            return False\r\n        \r\n        if getattr(self.right_character_loader, \"dead\", False):\r\n            return\r\n        dir_is_right = \"_right\" in self.character_sprite.texture.name\r\n        if self.up or self.down:\r\n            if dir_is_right:\r\n                self.character_sprite.texture = next(self.right_character_loader)\r\n            else:\r\n                self.character_sprite.texture = next(self.left_character_loader)\r\n        if self.up:\r\n            direction[1] += 1\r\n        if self.down:\r\n            direction[1] -= 1\r\n\r\n        if not self.up and not self.down and not self.left and not self.right:\r\n            if dir_is_right:\r\n                self.right_character_loader.reset()\r\n                self.character_sprite.texture = next(self.right_character_loader)\r\n            else:\r\n                self.left_character_loader.reset()\r\n                self.character_sprite.texture = next(self.left_character_loader)\r\n\r\n        direction_mag = numpy.linalg.norm(direction)\r\n        if direction_mag > 0:\r\n            direction = (\r\n                direction * util.PLAYER_MOVEMENT_SPEED / direction_mag\r\n            )  # Normalize and scale with speed\r\n\r\n            # Checking if x movement is valid\r\n            self.character_sprite.center_x += direction[0]\r\n            self.world_object.move_geometry(numpy.array([direction[0], 0]), 0)\r\n            if level.check_collisions(self) or self.character_sprite.collides_with_sprite(enemy.character_sprite):\r\n                self.character_sprite.center_x -= direction[0]\r\n                self.world_object.move_geometry(numpy.array([-direction[0], 0]), 0)\r\n\r\n            # Checking if y movement is valid\r\n            self.character_sprite.center_y += direction[1]\r\n            self.world_object.move_geometry(numpy.array([0, direction[1]]), 0)\r\n            if level.check_collisions(self) or self.character_sprite.collides_with_sprite(enemy.character_sprite):\r\n                self.character_sprite.center_y -= direction[1]\r\n                self.world_object.move_geometry(numpy.array([0, -direction[1]]), 0)\r\n\r\n            # Check if sound should be played\r\n            if not arcade.Sound.is_playing(self.walking_sound, self.player):\r\n                self.player = arcade.play_sound(self.walking_sound, self.walking_volume)\r\n\r\n        else:\r\n            # Check if sound should be stopped\r\n            if arcade.Sound.is_playing(self.walking_sound, self.player):\r\n                arcade.stop_sound(self.player)\r\n\r\n    def kill(self):\r\n        print(\"YOU DIED\")\r\n        self.status = \"dead\"\r\n\r\n    def get_mirror_in_reach(self, level):\r\n        closest_distance_squared = float('inf')\r\n        closest_mirror = None\r\n        for mirror in level.mirror_list:\r\n            distance_squared = mirror.distance_squared_to_center(\r\n                self.character_sprite.center_x,\r\n                self.character_sprite.center_y\r\n            )\r\n            if distance_squared < closest_distance_squared:\r\n                closest_mirror = mirror\r\n                closest_distance_squared = distance_squared\r\n        return closest_mirror if closest_distance_squared <= util.PLAYER_REACH_DISTANCE_SQUARED else None\r\n\r\n\r\nclass Enemy(Character):\r\n    def __init__(\r\n        self,\r\n        scale_factor=2,\r\n        image_width=24,\r\n        image_height=24,\r\n    ):\r\n        super().__init__(scale_factor, image_width, image_height)\r\n        self.state = \"asleep\"\r\n\r\n        self.left_character_loader = EnemySpriteLoader(\"left\")\r\n        self.right_character_loader = EnemySpriteLoader(\"right\")\r\n\r\n        self.character_sprite = util.load_sprite(\r\n            util.ENEMY_SLEEP_SPRITE,\r\n            scale_factor,\r\n            image_width=image_width,\r\n            image_height=image_height,\r\n            hit_box_algorithm=\"Simple\",\r\n        )\r\n\r\n    def update(self, level, player):\r\n        if self.state == \"aggro\":\r\n            x_diff = (player.character_sprite.center_x - self.character_sprite.center_x)\r\n            if x_diff < 0:\r\n                self.right = False\r\n                self.left = True\r\n            elif x_diff > 0:\r\n                self.left = False\r\n                self.right = True\r\n        \r\n        if self.update_sprite() is False:\r\n            return False\r\n        self.right = self.left = False\r\n\r\n        if self.state == \"asleep\":\r\n            self.character_sprite.texture = self.left_character_loader.stationary\r\n        elif self.state == \"aggro\":\r\n            direction = numpy.array(\r\n                [\r\n                    player.character_sprite.center_x - self.character_sprite.center_x,\r\n                    player.character_sprite.center_y - self.character_sprite.center_y,\r\n                ]\r\n            )\r\n\r\n            direction_mag = numpy.linalg.norm(direction)\r\n            if direction_mag > 0:\r\n                direction = (\r\n                    direction * util.ENEMY_MOVEMENT_SPEED / direction_mag\r\n                )  # Normalize and scale with speed\r\n\r\n                self.character_sprite.center_x += direction[0]\r\n                self.character_sprite.center_y += direction[1]\r\n                self.world_object.move_geometry(direction, 0)\r\n\r\n                if level.check_collisions(self):\r\n                    self.character_sprite.center_x -= direction[0]\r\n                    self.character_sprite.center_y -= direction[1]\r\n                    self.world_object.move_geometry(-direction, 0)\r\n\r\n                    perp_direction = numpy.array([-direction[1], direction[0]])\r\n                    self.character_sprite.center_x += perp_direction[0]\r\n                    self.character_sprite.center_y += perp_direction[1]\r\n                    self.world_object.move_geometry(perp_direction, 0)\r\n\r\n                    if level.check_collisions(self):\r\n                        self.character_sprite.center_x -= 2 * perp_direction[0]\r\n                        self.character_sprite.center_y -= 2 * perp_direction[1]\r\n                        self.world_object.move_geometry(-2 * perp_direction, 0)\r\n\r\n                if self.character_sprite.collides_with_sprite(player.character_sprite):\r\n                    player.kill()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumigator/entity.py b/illumigator/entity.py
--- a/illumigator/entity.py	(revision dc0dff134c351e10305c1f00e7ec653152a28998)
+++ b/illumigator/entity.py	(date 1690176515178)
@@ -175,7 +175,10 @@
         # Rotation
         if self.rotation_dir == 0:
             self.rotation_factor = 0
-        if self.rotation_factor < 3.00:
+
+        if self.mirror_in_reach is None:
+            self.rotation_factor = 0
+        elif self.rotation_factor < 3.00:
             self.rotation_factor += 1 / 15
 
         self.mirror_in_reach = self.get_mirror_in_reach(level)
